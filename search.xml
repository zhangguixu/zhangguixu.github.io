<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[认识CSP]]></title>
      <url>%2F2016%2F12%2F07%2Fcsp%2F</url>
      <content type="text"><![CDATA[CSP（Content Security Policy）即内容安全策略，是一种基于内容的声明式网络应用程序机制，对缓解内容注入漏洞（例如XSS）的危害非常有效。 下面详细介绍其原理和实践运用。 1. csp基础 工作原理:通过一系列指令告诉客户端（如浏览器）被保护资源（如页面）内只允许加载和执行指令集中限定的内容，类似白名单机制，不满足限定条件的资源和内容将被客户端阻断或不被执行。 目标定位：有效减少内容注入漏洞发生后所造成的危害（而非防止内容注入漏洞的发生） 限制范围：当前页面本身内容以及加载到当前页面的任何内容（包括页面加载完后通过js异步加载的内容） 2. 兼容性CSP Level 1标准，目前的支持程度很高，特别是移动端，该标准定义了强大的指令集，可以非常有效降低XSS漏洞的危害。而对于不支持CSP的浏览器，只是多了一些浏览器不能识别的信息，不会有什么影响，可以放心大胆地利用起来。 查阅兼容性的更多信息 配置的时候需要特别小心，可能会对现有业务功能产生影响，导致内容不可用。 3. CSP指令语法规则 指令1 值 值;指令2 值 值;指令3 值 3.1 指令CSP Level 1的指令 指令 说明 default-src 针对所有类型资源采取默认的加载策略，可覆盖 script-src 针对JavaScript的加载策略 style-src 针对样式的加载策略 img-src 针对图片的加载策略 connect-src 针对Ajax、webSocket等请求的加载策略，不允许时浏览器返回400 front-src 针对web font的加载策略 object-src 针对&lt;object&gt;&lt;embed&gt;&lt;applet&gt;等flash插件的加载策略 media-src &lt;audio&gt;&lt;video&gt;等标签引入的html多媒体的加载策略 frame-src 针对frame的加载策略，不推荐使用，在CSP Level 2被舍弃 sandbox 对请求的资源启用sandbox，类似于iframe的sandbox report-uri 记录页面请求不被策略允许资源的日志信息，并上报到该地址 CSP Level 2的指令 指令 说明 base-uri 限制当前页的url child-src 限制子窗口（iframe、弹窗）的源，取代frame-src form-action 限制表单能够提交到的源 frame-ancestors 限制了当前页面可以被哪些页面以iframe,frame,object等方式加载 plugin-types 限制插件的类型，例如pdf 3.2 特殊取值 指令值 说明 &nbsp; 指令值为空，不做任何限制 ‘none’ 不允许任何内容(要加引号) ‘self’ 允许同源的内容 ‘unsafe-inline’ 允许加载inline资源，例如style，onclick，inline js,css等 ‘unsafe-eval’ 允许加载动态js代码，例如eval() data: 允许data:协议，如base64编码的图片 www.example.com 允许加载指定域名的资源 *.example.com 运行加载example.com任何子域的资源 https 运行加载https资源 https://example.com 允许加载example.com的https资源 3.3 csp默认行为3.3.1 阻止内联代码执行CSP除了使用白名单机制外，默认配置下组织内联代码执行是防止内容注入的最大安全保障。 script标签 123&lt;script&gt; alert("Hello CSP");&lt;/script&gt; 内联事件 12&lt;a href="" onclick="handleClick()"&gt;&lt;/a&gt;&lt;a href="javscript:handleClick()"&gt;&lt;/a&gt; 内联样式 1&lt;div style="display:none"&gt;&lt;/div&gt; 在这种情况下，如果要开启内联的话，需要配置 1script-src 'unsafe-inline';style-src 'unsafe-inline' 3.3.2 EVAL相关功能被禁用用户输入字符串，然后经过eval()等函数转义进而被当作脚本去执行。这样的攻击方式比较常见。于是乎CSP默认配置下，eval() , new Function() , setTimeout([string], …) 和setInterval([string], …)都被禁止运行。 如果想要开启这些功能，可以使用&#39;unsafe-eval&#39;值 3.4 CSP上报日志为了能让违规的日志信息上报，必须使用report-uri指令，并至少提供一个接收地址 1Content-Security-Policy: report-uri url 违规报告为一个json对象，包含一下的数据： 12345678&#123; blocked-uri : 被阻止的违规资源 document-uri : 拦截违规行为发生的页面 original-policy : Content-Security-Policy头策略的所有内容 referrer : 页面的referrer status-code : HTTP响应状态 violated-directive : 违规的指令&#125; 4. 使用方式按照使用场景的不同，大致有三种使用方式。 4.1 策略制定处理，测试csp策略我们可以在页面头部添加 1&lt;meta http-equiv="Content-Security-Policy" content="default-src 'self';script-src 'self' *.example.com"&gt; 特点是 实现简单，只对当前页面有效 部分指令无效，例如report-uri（即无法上报） 4.2 线上验证观察需要在页面响应头添加Content-Security-Policy-Report-Only，这个时候只上报不符合策略的相关信息，不会真正阻止内容加载和执行。 4.3 线上最终部署通过页面响应头Content-Security-Policy，通过服务端配置即可对多个页面有效，一旦部署，只要浏览器支持CSP标准，则不符合策略的内容都将不被加载和执行。 4.4 实践建议CSP是基于内容白名单限制的方式阻止XSS攻击，一旦内容不满足条件则不会被加载和执行，因此，在制定策略的时候如果阻止了正常的内容，那可能导致业务功能受影响，这一点需要特别注意。 根据自己业务访问资源情况初步确定CSP内容， 确定资源白名单，可以使用策略default-src &#39;none&#39;，先阻止出了页面本身的所有其他内容的加载和执行，然后通过chrome控制台的提示的信息，确定哪些需要放进白名单，即可得到初步的策略 服务器配置Content-Security-Policy-Report-Only响应头，并指定上报url，用来收集阻止详情信息，以进一步验证和指导最终策略制定。 根据3和分析结果确认最终策略后，在服务器配置真正起作用的CSP响应头策略，同时添加report-uri指令来收集阻止内容的详情数据，以进行统计分析及采取进一步行动。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[XSS（跨站脚本攻击）]]></title>
      <url>%2F2016%2F12%2F07%2Fxss%2F</url>
      <content type="text"><![CDATA[跨站脚本（Cross-Site scripting）,又叫XSS，这个术语表示了一类安全问题，也就是攻击者向目标Web站点注入了HTML标签或脚本。 下面我们就来了解一下其背后的原理和如何进行简单的防御。 1. 攻击原理如果一个Web页面动态地产生文档内容，并且这些文档内容是基于用户提交的数据的，而并没有通过从中移除任何嵌入的HTML标签来”消毒”的话，那么这个Web页面很容易遭到跨站脚本的攻击。 例如：脚本使用JavaScript通过用户名字来向用户问好 12var name = decodeURIComponent(window.location.search.substring(1) || '');document.write('hello '+name); 考虑如果URL为 http://www.example.com/greet.html?%3Cscript%3Ealert(&apos;David&apos;)%3C/script%3E 注入的脚本就会显示一个对话框。此外，可以把其他站点的脚本注入到目标站点中，注入的脚本就可以对站点A的内容进行任何想要的操作。 2. 防止XSS攻击的办法2.1 标签符号转义在使用任何不可信的数据来动态的创建文档内容之前，对输出的内容进行标签符号的转义 12345678910111213function htmlEsc(s)&#123; if(!s) return ""; s = s + ""; if(s.length == 0) return ""; s = s.replace(/&amp;/g, "&amp;amp;"); s = s.replace(/&lt;/g, "&amp;lt;"); s = s.replace(/&gt;/g, "&amp;gt;"); s = s.replace(/ /g, "&amp;nbsp;"); s = s.replace(/\'/g, "&amp;#39;"); s = s.replace(/\"/g, "&amp;quot;"); s = s.replace(/\n/g, "&lt;br&gt;"); return s;&#125; 要养成这种意识 2.2 iframe的sandbox属性HTML5为元素定义了一个sandbox属性，在实现之后，它运行显示不可信的内容，并自动禁止脚本。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[同源策略]]></title>
      <url>%2F2016%2F12%2F07%2Fsame-origin%2F</url>
      <content type="text"><![CDATA[同源策略是对JavaScript代码能够操作哪些Web内容的一条完整的安全限制。具体来说，脚本只能读取和所属文档来源相同的窗口和文档的属性。 文档来源 协议 主机 端口 脚本本身的来源和同源策略并不相关，相关的是脚本所嵌入的文档的来源 作用场景： 使用多个 打开其他浏览器窗口 使用XmlHttpRequest 不严格的同源策略子域问题（document.domian）同源策略给使用多个子域的大站点带来一些问题。 例如：来自home.example.com的文档里的脚本想要合法地读取developer.example.com载入的文档的属性 为了支持这种类型的多域名站点，可以使用Document对象的domain属性。在默认情况下，domain存放的是载入文档的服务器的主机名。可以设置这一属性，不过使用的字符串必须具有有效的域前缀或它本身。 1234//设置home.example.com的文档document.domain = 'example.com';//设置developer.example.com的文档document.domain = 'example.com'; 这样，两个子域就具有同源性，就可以互相读取对方的属性了。 domain值中必须有一个点号，不能设置为com或其他顶级域名。 跨域资源共享（CORS）Cross-Origin Resource Sharing这项技术已经成为一项标准，参见：http://www.w3.org/TR/cors/ 这个标准对HTTP进行扩展： 新的Origin:请求头 新的Access-Control-Allow-Origin响应头 它允许服务器用头信息显示地列出源，或使用通配符来匹配所有源并允许跨域HTTP请求，已经运用到XMLHttpRequest Level 2。这样就不会被同源策略所限制了。 跨文档消息跨文档消息（cross-document messaging），允许来自一个文档的脚本可以传递文本消息到另一个文档里的脚本，而不管脚本的来源是否不同。调用window对象的postMessage()，方法，可以异步传递消息，利用onmessage事件处理函数来处理它。采用域判断来确定信任源。 12345678910111213141516171819202122232425262728293031//文档A发送消息给文档BchatFrame.contentWindow.postMessage('hello','http://www.example.com/')//文档B监听message事件window.addEventListener('message',messageHandler,true);function messageHandler(e)&#123; if(checkWhiteList(e.origin))&#123; //处理消息 processMessage(e.data); &#125;else&#123; //忽略来自未知源的消息 &#125;&#125;//进行源的判断var originWhiteList=['portal.example.com','games.example.com', 'www.example.com'];function checkWhiteList(origin)&#123; var i; for(i = 0;i &lt; originWhiteList.length;i++)&#123; if(origin === originWhiteList[i])&#123; return true &#125; &#125; return false;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[客户端JavaScript的限制]]></title>
      <url>%2F2016%2F12%2F07%2Frestriction%2F</url>
      <content type="text"><![CDATA[处于安全的考虑，客户端的js运行会受到种种限制，下面就让我们来了解一下。 浏览器的限制浏览器限制了JavaScript任务的运行时间。这种限制是有必要的，它确保某些恶意代码不能通过永不停止的密集操作锁住用户的浏览器或计算机。此类限制分为两种 调用栈大小限制 长时间运行脚本限制 单个JavaScript操作花费的总时间(最大值)不应该超过100毫秒。这个数字源自Robert Miller于1968年的研究。Nielsen指出如果界面在100毫秒内响应用户输入，用户会认为自己在“直接操纵界面中的对象”。超过100毫秒意味着用户会感到自己与界面失去的联系。 建议是在50ms内 浏览器不支持的功能 JavaScript没有权限写入或删除客户计算机上的任意文件或列出任意目录 意味着JavaScript程序不能删除数据或植入病毒。 客户端JavaScript没有任何通用的网络能力。 虽然客户端JavaScript程序可以对HTTP协议编程，此外还有WebSockets，但是这些API都不允许对于范围更广的网络进行直接访问。 浏览器限制的功能 JavaScript程序可以打开一个新的浏览器窗口，但是为了防止广告商滥用弹出窗口，很多浏览器限制这一功能，使得只有为了响应鼠标单击这样的用户触发事件的时候，才能使用。 JavaScript程序可以关闭自己打开的浏览器窗口，但是不允许它不经过用户确认就关闭其他的窗口。 HTML FileUpload元素的value属性是只读的。 脚本不能读取从不同服务器载入的文档的内容，除非这个就是包含该脚本的文档。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Worker基础知识]]></title>
      <url>%2F2016%2F12%2F07%2Fworker%2F</url>
      <content type="text"><![CDATA[我们都知道客户端JavaScript有一个基本的特性就是单线程。这是有一定历史原因的，暂且不深究。随着web应用的越来越复杂，客户端的js可能会承担越来越繁重的计算任务，从而导致UI线程被阻塞无法及时响应用户的操作。 worker的出现，就是来解放主线程的js的计算任务的，由于安全的考虑，worker也会受到一定的限制。 1. 基本知识在Web Worker标准中，定义了解决客户端JavaScript无法多线程的问题。 worker是指执行代码的并行线程。 Web Workers处在一个自包含的执行环境，无法访问Window对象和Document对象，和主线程之间的通信也只能通过异步消息传递机制来实现。 提供一种使用异步API的方式，同时运行书写需要长时间运行的函数而不会带来循环事件和导致浏览器崩溃的问题。 Web Workers标准中，有两部分组成Worker对象和WorkerGlobalScope全局对象。 2. Worker对象 使用构造函数Worker()创建Worker对象 1var loader = new Worker(url) url:可以采用相对路径和绝对路径，但是采用绝对路径必须和包含该脚本的文档是同源的。 使用postMessage()传递参数给Worker 传递给postMessage()方法的值hi赋值，最终的副本会通过message事件传递给Worker 1loader.postMessage('file.txt'); 通过message事件来接收Work的响应消息 1234worker.onmessage = function(e)&#123; var message = e.data; console.log('URL contents: ' + message);&#125; 使用terminate()终止Worker 123456worker.onmessage = function(e)&#123; //接收处理Worker的响应消息 //终止worker worker.terminate();&#125; 此外，Worker可以通过error事件来处理异常。 1234worker.onerror = function(e)&#123; concole.log('Error at ' + e.filename + ':' + e.lineno + ':' + e.message);&#125; 和所有事件目标一样，Worker对象也定义了标准的addEventListener()和removeEventListener() 3. WorkerGlobalScope全局对象在通过Worker()构造函数创建一个新Worker的时候，指定了包含JavaScript代码文件的URL。该代码会运行在一个全新的JavaScript运行环境中，完全和创建Worker的脚本隔离开来。 WorkerGlobalScope全局对象表示了该新的运行环境，它是新创建的Worker的全局对象。 3.1 与外部Worker的通信1. postMessage() &amp; message事件 WorkerGlobalScope对象同样有postMessage()方法和message事件，利用这两者可以与外部Worker进行通信 1234//worker内部onmessage = function(e)&#123; postMessage(e.data);&#125; 2. close() 同样，Worker可以使用close()来关闭自己，但是要注意的是，Worker对象上没有定义任何API用于检测Worker是否已关闭。因此，如果一个Worker要使用close()方法将自己关闭，那么最好是先传递”关闭”的信息。 3. importScripts() Worker内部使用此方法来加载任何需要的库代码。而是此方法是一个同步的方法，它在直到所有的脚本都已经载入并运行完成才会返回。 12//在开始工作前，现在如需要的类、工具函数importScript('collections/Set.js','utils/base64.js'); 3.2 WorkerGlobalScope的属性它拥有所有核心JavaScript全局对象拥有的属性，同时，还拥有部分客户端Window对象的一些属性。 self：对全局对象自身的引用 计数器方法：setTimeout()/clearTimeout()/setInterval()/clearInterval() location：只读 navigator 常用的事件目标方法：addEventListener()和removeEventListener() onerror属性 4. 应用场景：脚本化HTTP请求WorkerGlobalScope对象好包含一些重要的构造函数，其中就有XMLHttpRequest()，以便Worker可以通过它进行脚本化的HTTP请求。 在Worker中发起同步的XmlHttpRequest 1234567891011121314151617181920//Worker内部onmessage = function(e)&#123; var urls = e.data; //要获取的url var contents = []; //url指定的内容 var i,len,url; for(i = 0, len = urls.length; i &lt; len; i++)&#123; var url = urls[i]; var xhr = new XMLHttpRequest(); xhr.open('GET',url,false);//false表示进行同步请求 xhr.send(); if(xhr.status !== 200)&#123; throw Error(xhr.status + ' ' + xhr.statusText + ': ' + url); &#125; contents.push(xhr.responseText); &#125; //返回url的内容 postMessage(contents);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[事件类型总结]]></title>
      <url>%2F2016%2F12%2F06%2Fevent-type%2F</url>
      <content type="text"><![CDATA[在DOM3级事件规定了以下几类事件： UI事件(UIEvents)，当用户与页面上的元素交互时触发 焦点事件，当元素获得或失去焦点时触发 鼠标事件(MouseEvents)，当用户通过鼠标在页面上执行操作时触发 滚轮事件()，当使用鼠标滚轮时触发 文本事件，当在文档中输入文本时触发 键盘事件(KeyboardEvent)，当用户通过键盘在页面上执行操作时触发 合成事件，当为IME输入字符时触发 变动事件(MutationEvents)，当底层DOM结构发生变化时触发 不同的事件类型具有不同的信息。此外，有些浏览器还会在DOM和BOM中实现其专有事件，HTML5还定义了一组事件。 我们可以通过document.createEvent(type)来创建一个事件（已有的事件或者自定义事件都可以） 12345678910111213// 创建一个事件var event = document.createEvent("Event");// 初始化事件的相关信息event.initEvent("build", true, true);// 元素可以监听这个事件el.addEventListener("build", function(e)&#123; // 做处理&#125;, false);// 需要在脚本中触发事件，就会执行相对应的回调el.dispatchEvent(event); 1. UI事件常见的UI事件有 load/unload abort error select resize scroll 1.1 load/unload 事件会触发load事件的情况： 页面完全加载后（包括所有外部资源），会触发window上面的load事件 图像的加载也会触发load事件，无论是&lt;img&gt;标签还是Image对象，但要注意的是在IE8及之前版本不会生成event对象。 在IE9+、firefox、opera、chrome、safari3+等浏览器中，&lt;script&gt;也会触发load事件，以便开发人员确定动态加载的js文件是否加载完毕。 IE和Opera还支持&lt;link&gt;元素上的load事件 与load事件对应就是unload事件，这个事件在文档被完全卸载后触发，其实用户从一个页面切换到另一个页面就会发生unload事件，而利用这个事件最多的情况是清除引用，以避免内存泄漏。 另外说明一点，通常我们会在页面中看到： 123456789&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;example&lt;/title&gt; &lt;/head&gt; &lt;body onload="" onunload=""&gt; &lt;/body&gt;&lt;/html&gt; 一般来说，在window上面发生的任何事件都可以在body元素中通过相应的属性来指定，因为在HTML中无法访问window对象，实际上，这只是为了保证向后兼容的一种权宜之计，但所有浏览器都能很好地支持这种方式。 1.2 resize事件当浏览器窗口被调整到一个新的高度或宽度时，就会触发resize事件，这个事件在window上面触发。 浏览器窗口最小化或最大化时也会触发resize事件。 resize事件可能会被频繁触发，浏览器会有一些机制来保证两个resize事件触发有一定的间歇（例如20ms），我们自己在处理的时候也要特别注意，详情见函数节流。 1.3 scroll事件 scroll事件是在window对象上发生的，但它实际表示的则是页面中相应元素的变化。 在混杂模式下，可以通过body元素的scrollLeft和scrollTop来监控这一变化。 在标准模式下，除了safari（仍然是通过body），所有浏览器都会通过html元素来反应这一变化。 1234567window.addEventListener("scroll", function(e)&#123; if(document.compatMode == "CSS1Compat")&#123; alert(document.documentElement.scrollTop); &#125; else &#123; alert(document.body.scrollTop); &#125;&#125;, false); 需要注意的是，scroll事件在文档被滚动期间会被重复地触发，跟resize的处理类似。 2. 焦点事件焦点事件会在页面元素获得或失去焦点时触发，利用这些事件并与 document.hasFocus() document.activeElement 就可以知晓用户在页面上的行踪。 常见焦点事件共有： blur：在元素失去焦点时触发，这个事件不会冒泡，所有浏览器都支持 focus：在元素获得焦点时触发，这个事件不会冒泡，所有浏览器都支持 focusin：在元素获得焦点时触发，这个事件与HTML事件focus等价，但是会冒泡。支持的浏览器有IE5.5+、opera 11.5+、chrome、safari 5.1+ focusout：在元素失去焦点时触发，这个事件与HTML事件blur等价，支持的浏览器有IE5.5+、opera 11.5+、chrome、safari 5.1+ DOMFocusIn和DOMFocusOut只有Opera支持，这里就不介绍。 当焦点从页面中的一个元素移动到另一个元素时，会依次触发下列事件： focusout在失去焦点的元素中触发 focusin在获得焦点的元素中触发 blur在失去焦点的元素上触发 focus在获得焦点的元素中触发 3. 鼠标与滚轮事件鼠标事件是Web开发中最常用的一类事件，常见的鼠标事件有： click：在用户单击鼠标按钮或者按下回车键时触发。 dbclick：在用户双击鼠标按钮时触发，在DOM3级事件纳入了标准。 mousedown：在用户按下了任意鼠标按钮时触发。 mouseenter：在鼠标光标从元素外部首次移动到元素范围之内触发，这个事件不冒泡，而且在光标移动到后代元素上不会触发。 mouseleave： 参考 《JavaScript高级程序设计》 document.createEvent()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[事件触发]]></title>
      <url>%2F2016%2F12%2F06%2Fevent-trigger%2F</url>
      <content type="text"><![CDATA[前置知识： 跨浏览器的事件处理程序实现 事件触发一般会发生在：用户交互时、浏览器行为发生时、网络活动时。 这里讨论的是用脚本来触发事件，当我们触发一个处理函数时，还要确保以下的几点： 触发绑定在该元素上的目标处理程序 让DOM事件进行冒泡，并触发其他的处理程序 触发该模板元素的默认行为 下面我们就看看如何实现？ 1. 代码实现前置知识：跨浏览器的事件监听函数 123456789101112131415161718192021222324252627function triggerEvent(el, event)&#123; var data = getData(el), parent = el.parentNode || el.ownerDocument; // 获取父元素用于冒泡 if(typeof event == "string")&#123; event = &#123;type : event, target : el&#125;; &#125; event = fixEvent(event); // 如果之前绑定了事件处理程序了，则执行 if(data.dispatcher)&#123; data.dispatcher.call(el, event); &#125; // 除非禁止冒泡，不然则一直递归调用 if(parent &amp;&amp; !event.isPropagationStopped())&#123; triggerEvent(parent, event); &#125; else if (!parent &amp;&amp; !event.isDefaultPrevented())&#123;// 触发默认行为 var targetData = getData(event.target); if(event.target[event.type])&#123; // el.focus()? targetData.disabled = true; // 先禁用 event.target[event.type](); // 执行默认行为 targetData.disabled = false; &#125; &#125;&#125; 2. 自定义事件自定义事件其实是观察者模式的一个很好的实践，通过自定义事件和事件绑定处理程序的方式来为我们的程序代码进行解耦，是一个很实用的编程技巧。 下面，我们通过一个例子来理解一下这样做的好处。 2.1 ajax示例在一个页面上，我们希望在ajax请求开始时，显示一个转轮的gif动画，并且在请求结束时将动画进行隐藏，以便在处理请求时给用户一些反馈。 如果有一个事件为ajax-start，另一个事件为ajax-complete，那么我们就可以给这两个事件绑定事件处理程序，这样就可以轻松做到以上的要求了。 123456789101112var body = document.body;var gif = document.createElement("img");gif.src = "1.gif";addEvent(body, "ajax-start", function(e)&#123; this.appendChild(gif);&#125;);addEvent(body, "ajax-complete", function(e)&#123; this.removeChild(gif);&#125;); 那么现在有一个问题，就是这些事件并不存在，也就是说，我们需要自定义这样两个事件ajax-start和ajax-complete，并且，我们需要用脚本来触发，模拟一个事件回调的机制。 12345678910// 一个发送ajax请求的接口function ajax(url)&#123; // 创建，发送请求之前，执行回调 triggerEvent(body, "ajax-start"); // 成果返回 ajax.success(function()&#123; triggerEvent(body, "ajax-complete"); &#125;);&#125; 来源 《JavaScript忍者秘籍》]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[跨浏览器的事件处理程序实现]]></title>
      <url>%2F2016%2F12%2F06%2Fevent-listener%2F</url>
      <content type="text"><![CDATA[在学习了 事件基础知识 事件对象属性 之后，我们来看看如何实现一个跨浏览器的事件处理程序。 1. 初步实现在《JavaScript高级程序设计》中提供了一个EventUtil的对象，里面实现了一个跨浏览器的事件绑定的API 1234567891011121314151617181920var EventUtil = &#123; addHandler : function (el, type, handler) &#123; if(el.addEventListener) &#123; el.addEventListener(type, handler, false); &#125; else if (el.attachEvent)( el.attachEvent("on" + type, handler); ) else &#123; el["on" + type] = handler; &#125; &#125;, removeHandler : function (el, type, handler) &#123; if(el.removeEventListener) &#123; el.removeEventListener(type, handler); &#125; else if (el.detachEvent) &#123; el.detachEvent("on" + type, handler); &#125; else &#123; el["on" + type] = null; &#125; &#125;&#125; 这是实现其实较为的简单直观，但是对于IE浏览器的处理其实有不好的地方，例如我们都知道attachEvent()中的事件处理程序会在全局作用域下执行，那么函数中的this就会指向window对象，这是一个问题，当然我们也可以对handler进行处理，绑定handler的函数作用域。此外，EventUtil并没有对event对象进行处理，因此传入handler的event也需要做兼容性处理，在封装方面做的就不好，编写handler时需要注意的地方就比较多。 123456var handler = function (event) &#123; // 对event对象做兼容性处理，例如获取target等&#125;;// 绑定函数作用域handler = handler.bind(el); 2. 更好的实现下面是Dean Edward的实现，这也是jquery所借鉴的，抛弃掉attachEvent方法，直接使用跨浏览器的实现方式，即el.onXXX = handler，这种方式的确定就是无法绑定多个，会进行覆盖，但是可以利用一些技巧来弥补。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// written by Dean Edwards, 2005// with input from Tino Zijdel, Matthias Miller, Diego Perini// http://dean.edwards.name/weblog/2005/10/add-event/function addEvent(element, type, handler) &#123; if (element.addEventListener) &#123; element.addEventListener(type, handler, false); &#125; else &#123; // assign each event handler a unique ID if (!handler.$$guid) handler.$$guid = addEvent.guid++; // create a hash table of event types for the element if (!element.events) element.events = &#123;&#125;; // create a hash table of event handlers for each element/event pair var handlers = element.events[type]; if (!handlers) &#123; handlers = element.events[type] = &#123;&#125;; // store the existing event handler (if there is one) if (element["on" + type]) &#123; handlers[0] = element["on" + type]; &#125; &#125; // store the event handler in the hash table handlers[handler.$$guid] = handler; // assign a global event handler to do all the work element["on" + type] = handleEvent; &#125;&#125;;// a counter used to create unique IDsaddEvent.guid = 1;function removeEvent(element, type, handler) &#123; if (element.removeEventListener) &#123; element.removeEventListener(type, handler, false); &#125; else &#123; // delete the event handler from the hash table if (element.events &amp;&amp; element.events[type]) &#123; delete element.events[type][handler.$$guid]; &#125; &#125;&#125;;function handleEvent(event) &#123; var returnValue = true; // grab the event object (IE uses a global event object) event = event || fixEvent(((this.ownerDocument || this.document || this).parentWindow || window).event); // get a reference to the hash table of event handlers var handlers = this.events[event.type]; // execute each event handler for (var i in handlers) &#123; this.$$handleEvent = handlers[i]; if (this.$$handleEvent(event) === false) &#123; returnValue = false; &#125; &#125; return returnValue;&#125;;function fixEvent(event) &#123; // add W3C standard event methods event.preventDefault = fixEvent.preventDefault; event.stopPropagation = fixEvent.stopPropagation; return event;&#125;;fixEvent.preventDefault = function() &#123; this.returnValue = false;&#125;;fixEvent.stopPropagation = function() &#123; this.cancelBubble = true;&#125;; 这段代码其实是对IE浏览器事件绑定的一个修补，特别是旧版本的（IE8及更早的版本）。jquery借鉴了这样的一个思路，写出了兼容各个浏览器的event模块。 3. jquery的实现思路在《JavaScript忍者秘籍》中，给出了一个更加高级的实现，他使用一个中间事件处理程序，并将所有的处理程序都保存在一个单独的对象上，最大化地控制处理的过程，这样做有几个好处： 规范处理程序的上下文，这个指的是作用域的问题，正常来说，元素的事件处理程序的上下文应该就是元素本身，即this === el为true。 修复Event对象的属性，通过兼容性的处理，来达到与标准无异。 处理垃圾回收 过滤触发或删除一些处理程序 解绑特定类型的所有事件 克隆事件处理程序 依照这样的一个思路，我们来一步步实现这样一个模块。 3.1 修复Event对象的属性修复主要针对一些重要的属性进行修复，结合上一节的内容，有以下代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374function fixEvent(event) &#123; function returnTrue () &#123;return true;&#125; function returnFalse () &#123;return false;&#125; if(!event || !event.stopPropagation) &#123; // 判断是否需要修复 var old = event || window.event; // IE的event从window对象中获取 event = &#123;&#125;; // 复制原有的event对象的属性 for(var prop in old) &#123; event[prop] = old[prop]; &#125; // 处理target if(!event.target) &#123; event.target = event.srcElement || document; &#125; // 处理relatedTarget event.relatedTarget = event.fromElement === event.target ? event.toElement : event.fromElement; // 处理preventDefault event.preventDefault = function () &#123; event.returnValue = false; // 标识，event对象是否调用了preventDefault函数 event.isDefaultPrevented = returnTrue; &#125; /* 可以调用event.isDefaultPrevented()来查看是否调用event.preventDefault */ event.isDefaultPrevented = returnFalse; event.stopPropagation = function () &#123; event.cancelBubble = true; event.isPropagationStopped = returnTrue; &#125; event.isPropagationStopped = returnFalse; // 阻止事件冒泡，并且阻止执行其他的事件处理程序 // 借助标识位，可以在后面进行handlers队列处理的时候使用 event.stopImmediatePropagation = function () &#123; event.isImmediatePropagationStopped = returnTrue; event.stopPropagation(); &#125; event.isImmediatePropagationStopped = returnFalse; // 鼠标坐标，返回文档坐标 if(event.clientX != null)&#123; var doc = document.documentElement, body = document.body; event.pageX = event.clientX + (doc &amp;&amp; doc.scrollLeft || body &amp;&amp; body.scrollLeft || 0) - (doc &amp;&amp; doc.clientLeft || body &amp;&amp; body.clientLeft || 0); event.pageY = event.clientY + (doc &amp;&amp; doc.scrollTop || body &amp;&amp; body.scrollTop || 0) - (doc &amp;&amp; doc.clientTop || body &amp;&amp; body.clientTop || 0); &#125; event.which = event.charCode || event.keyCode; // 鼠标点击模式 left -&gt; 0 middle -&gt; 1 right -&gt; 2 if(event.button != null)&#123; event.button = (event.button &amp; 1 ? 0 : (event.button &amp; 4 ? 1 : (event.button &amp; 2 ? 2 : 0))); &#125; &#125; return event;&#125; 3.2 中央对象保存dom元素信息这个的目的是为了给元素建立一个映射，标识元素和存储相关联的信息(事件类型和对应的事件处理程序)，在jquery里面使用的是selector，在《JavaScript忍者秘籍》中，使用的是guid。 12345678910111213141516171819202122232425var cache = &#123;&#125;, guidCounter = 1, expando = "data" + (new Date).getTime();function getData(el) &#123; var guid = el[expando]; if(!guid)&#123; guid = el[expando] = guidCounter++; cache[guid] = &#123;&#125;; &#125; return cache[guid];&#125;function removeData(el) &#123; var guid = el[expando]; if(!guid) return; delete cache[guid]; try &#123; delete el[expando]; &#125; catch(e)&#123; if(el.removeAttribute)&#123; el.removeAttribute(expando); &#125; &#125;&#125; 3.3 绑定事件处理程序12345678910111213141516171819202122232425262728293031323334353637383940var nextGuid = 1;function addEvent(el, type, fn) &#123; var data = getData(el); if(!data.handlers)data.handlers = &#123;&#125;; if(!data.handlers[type])data.handlers[type] = []; // 给事件处理程序赋予guid，便于后面删除 if(!fn.guid)fn.guid = nextGuid++; data.handlers[type].push(fn); // 为该元素的事件绑定统一的回调处理程序 if(!data.dispatcher) &#123; // 是否启用data.dispatcher data.disabled = false; data.dispatcher = function (event) &#123; if(data.disabled)return; event = fixEvent(event); var handlers = data.handlers[event.type]; if(handlers) &#123; for(var i = 0, len = handlers.length; i &lt; len; i++)&#123; handlers[i].call(el, event); &#125; &#125; &#125;; &#125; // 将统一的回调处理程序注册到，仅在第一次注册的时候需要 if(data.handlers.length === 1)&#123; if(el.addEventListener)&#123; el.addEventListener(type, data.dispatcher, false); &#125; else (el.attachEvent) &#123; el.attachEvent("on" + type, data.dispatcher); &#125; &#125;&#125; 3.4 清理资源绑定了事件，就还需要一个解绑事件，因为我们使用的是委托处理程序来控制处理流程，而不是直接绑定处理程序，所以也不能直接使用浏览器提供的解绑函数来处理。在这里，我们需要手动来清理一些资源，清理的顺序从小到大。 1234567891011121314151617181920212223242526272829303132function isEmpty(o)&#123; for(var prop in o)&#123; return false; &#125; return true;&#125;function tidyUp(el, type) &#123; var data = getData(el); // 清理el的type事件的回调程序 if(data.handlers[type].length === 0) &#123; delete data.handlers[type]; if(el.removeEventListener)&#123; el.removeEventListener(type, data.dispatcher, false); &#125; else if(el.detachEvent)&#123; el.detachEvent("on" + type, data.dispatcher); &#125; &#125; // 判断是否还有其他类型的事件处理程序，如果没有则进一步清除 if(isEmpty(data.handlers))&#123; delete data.handlers; delete data.dispatcher; &#125; // 判断是否还需要data对象 if(isEmpty(data)) &#123; removeData(el); &#125;&#125; 3.5 解绑事件处理程序为了尽可能保持灵活，提供了以下的功能 将一个元素的所有绑定事件进行解绑 1removeEvent(el); 将一个元素特定类型的所有事件进行解绑 1removeEvent(el, "click"); 将一个元素的特定处理程序进行解绑 1removeEvent(el, "click", handler); 1234567891011121314151617181920212223242526272829303132333435363738394041function removeEvent(el, type, fn) &#123; var data = getData(el); if(!data.handlers)return; var removeType = function(t) &#123; data.handlers[t] = []; tidyUp(el, t); &#125;; // 删除所有的处理程序 if(!type)&#123; for(var t in data.handlers)&#123; removeType(t); &#125; return; &#125; var handlers = data.handlers[type]; if(!handlers)return; // 删除特定类型的所有事件处理程序 if(!fn)&#123; removeType(type); return; &#125; // 删除特定的事件处理程序，这个时候根据guid来进行删除 // 这里需要考虑的就是可能一个事件处理程序被绑定到一个事件类型多次 // 因此，这里需要用到handlers.length，删除的时候，需要n-- if(fn.guid) &#123; for(var n = 0; n &lt; handlers.length; n++)&#123; if(handlers[n].guid === fn.guid)&#123; handlers.splice(n--, 1); &#125; &#125; &#125; // 返回之前进行资源清理 tidyUp(el, type);&#125; 到这里，我们就得到一个既保证通用性又保证性能的事件监听处理模块，然而事件的知识并不仅仅这么一点，本章节的内容将会继续出现在接下来的几个小节，一起构建一个完整的event体系的代码库。 4. 参考 《JavaScript高级程序设计》 《JavaScript忍者秘籍》 addEvent]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Event对象详解]]></title>
      <url>%2F2016%2F12%2F06%2Fevent-properties%2F</url>
      <content type="text"><![CDATA[当一个事件触发时，就会产生一个event对象，然后传递到事件处理程序中，这个对象会携带事件触发时的信息。 本节主要谈论event对象中的一些重要的属性以及这些属性在IE和其他浏览器中的区别。 本文的IE都是指IE9之前的版本 1. target表示事件原始源的属性。在IE中，原始源保存在srcElement中 2. relatedTarget表示事件触发时的关联属性（mouseover或mouseout），在IE中则是toElement和fromElement 3. preventDefault表示阻止默认浏览器行为的发生。该属性在IE中不存在的，要达到一样的效果需要将returnValue置为false。 4. stopPropagation表示阻止事件冒泡。在IE中，不存在该属性，要达到一样的效果需要将cancelBubble置为true。 5. pageX &amp; pageY提供了鼠标相对于整个文档的位置。在IE中不存在，我们需要通过 clientX/Y : 提供鼠标相对于窗口的位置 scrollTop/Left : 提供文档滚动的位置 clientTop/Left : 提供文档的偏移量 这三个属性来计算出最后的pageX/Y的值。 6. which表示键盘事件时所按键的键盘码。在IE中，可以通过charCode和keyCode属性获取到。 7. button表示鼠标事件发生时，用户单击的鼠标按键。在IE中使用了位掩码 左单击是1 中间单击是4(即滚轮) 右击是2 需要将其转换为标准的等价值0，1，2。 来源 《JavaScript忍者秘籍》 Event对象的兼容性]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[事件基础概念]]></title>
      <url>%2F2016%2F12%2F06%2Fevent-basis%2F</url>
      <content type="text"><![CDATA[Event是前端开发必须掌握的知识，下面就看了解一下其背后的原理。 1. 背景知识跟所有开发UI的思路一样，JavaScript与HTML之间通过事件来进行交互。事件，就是文档或浏览器窗口中发生的一些特定的交互瞬间，我们使用监听器（listener/hanlder）来预订事件，当事件触发时，执行相对应的代码，这种就是传统软件工程中被成为观察者模式的模型，这种模型支持页面的行为与页面的UI之间的松散耦合。 2. 事件流理解事件流，我们可以从一个问题出发，那就是：页面的哪一个部分会拥有某个特定的事件？当我们点击了一个button时，点击事件不仅发生在按钮上，换句话说，在单击按钮的同时，也是单击了按钮的容器元素，甚至也单击了整个页面。 这便有了事件流的概念，它描述的就是从页面中接收事件的顺序。而事件流有两种： 事件冒泡 事件捕获 早期，IE和Netscape的事件流顺序是相反的，IE是事件冒泡流，Netscape是事件捕获流。 2.1 事件冒泡IE的事件流叫做事件冒泡（event bubbling），即事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点。 例如： 123456789&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Event Bubbling&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;click&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 当我们点击页面中的div元素时，这个click事件会按照如下的顺序传播 IE9、firefox、chrome和safari会将事件一直冒泡到window对象。 2.2 事件捕获NetScape提出的另一种事件流叫做事件捕获，即是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件，它的用意在于事件到达预定目的之前捕获它。 还是以上面的html代码为例子，则当我们点击页面的div元素时，这个click事件的顺序为： 2.3 DOM 事件流DOM2级事件规定事件流包括三个阶段： 事件捕获阶段，为截获事件提供了机会 处于目标阶段，实际的目标接收到事件 事件冒泡阶段，也可以在这个阶段对事件作出响应 需要注意的有两点： 尽管DOM2级事件规范要求事件应该从document对象开始传播，但是大多数浏览器都是从window对象开始捕获的。 DOM2级明确要求捕获阶段不会涉及事件目标，但是IE9，safari，chrome，firefox和opera9.5都会在捕获阶段触发事件对象上的事件，结果，就是有两个机会在目标对象上操作事件。 IE8及更早版本不支持DOM事件流。 3. 事件处理程序事件是用户或浏览器自身执行的某种动作，而响应某个事件的函数就叫做事件处理程序。 设置事件处理程序的方式有4种，以下来一一介绍。 3.1 HTML事件处理程序某个元素支持的事件，都可以使用一个与相应事件处理程序同名的HTML属性来指定，这个属性的值应该是能够执行的JavaScript代码，例如： 1&lt;input type="button" id="btn" value="click" onclick="alert('click')" /&gt; 我们可以直接在属性中的js代码中通过event变量获取到event对象，代码中的this指的是事件的目标元素。 1&lt;input type="button" value="click" onclick="alert(event.type);alert(this.value);" /&gt; 这种方式在很多古老的页面中都可以看到，它比较的简单，粗暴。但是它导致了HTML与JavaScript代码紧密耦合，从实践的角度上，最好不要采用这样的形式。 3.2 DOM0级事件处理程序通过JavaScript指定的事件处理程序的传统方式，就是将一个函数赋值给一个事件处理程序属性。 这个方式有两个优点： 简单 跨浏览器，至今所有的现代浏览器都支持。 12345var btn = document.getElementById("btn");btn.onclick = function (event) &#123; alert(event.type); alert(this.id);&#125; 需要注意的是，通过这个方式进行设置，我们无法对同一个元素的同一个事件绑定多个事件处理程序（会覆盖），例如以下代码，就只会执行最后设置的函数。 12345678var btn = document.getElementById("btn");btn.onclick = function (event) &#123; // 不会执行 alert(event.type); alert(this.id);&#125;btn.onclick = function (event) &#123; alert("覆盖了");&#125; 依据这个特性，我们可以通过btn.onclick = null来删除设置的事件处理程序。当然我们也可以通过以下的技巧，来为其绑定多个事件处理程序。 123456789101112var btn = document.getElementById("btn");btn.onclick = function (event) &#123; alert(event.type); alert(this.id);&#125;var oldHandler = btn.onclick; // 获取前面设置的事件处理程序btn.onclick = function (event) &#123; oldHandler.call(this, event); alert("覆盖了");&#125; 3.3 DOM2级事件处理程序DOM2级事件定义了两个方法，用于处理指定和删除事件程序的操作 addEventListener(type, listener, isCapture) removeEventListener(type, listener, isCapture) 它们接收三个参数： 要处理的事件名（不需要带on，例如点击事件是click） 作为事件处理程序的函数 布尔值，为true时表示捕获阶段调用事件处理程序，为false则表示冒泡阶段调用事件处理程序 12345var btn = document.getElementById("btn");btn.addEventListener("click", function (event) &#123; alert(event.type); alert(this.id);&#125;, false); 使用这个方式的主要好处就是可以添加多个事件处理程序 12345678var btn = document.getElementById("btn");btn.addEventListener("click", function (event) &#123; alert(event.type); alert(this.id);&#125;, false);btn.addEventListener("click", function (event) &#123; alert("hello world");&#125;, false); 通过addEventListener方式添加的事件处理程序只能通过removeEventListener来删除，这就是说如果我们采用匿名函数的方式来添加事件处理程序的话，则无法进行删除，因此比较好的方式就是： 123456789var btn = document.getElementById("btn");function handler(event) &#123; alert(event.type); alert(this.id);&#125;btn.addEventListener("click", handler, false);btn.removeEventListener("click", handler, false); 在大多数情况下，都是将事件处理程序添加到事件流的冒泡阶段，这样可以最大限度地兼容各种浏览器。 3.4 IE事件处理程序IE实现了与DOM中类似的两个方法： attachEvent(type, listener) detachEvent(type, listener) 参数type是on+事件名，如点击事件，则是onclick 由于IE8及更早版本只支持事件冒泡，所以通过attachEvent()添加事件处理程序都会被添加到冒泡阶段。 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Event Bubbling&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;input type="button" id="btn" value="click"/&gt; &lt;script type="text/javascript"&gt; var btn = document.getElementById("btn"); btn.attachEvent("onclick", function (event)&#123; alert(event.type); alert(this.id); // undefined alert(this === window); // true &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 上面的代码其实是有问题的，当alert(this.id)时，会看到结果为undefined，这就是使用这个方法特别要注意的地方，事件处理程序会在全局作用域中运行，因此this等于window。 我们可以运用一个小技巧，来修复这个问题。 12345678910var btn = document.getElementById("btn");function handler(event) &#123; alert(event.type); alert(this.id);&#125;btn.attachEvent("onclick", function (event)&#123; handler.call(btn, event); // 绑定作用域&#125;); 其他的地方，attachEvent()就跟addEventListener()类似，都可以绑定多个事件处理程序，要删除只能调用detachEvent()，并且不能使用匿名函数的形式。 支持IE事件处理程序的浏览器有IE和Opera]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[es6系列-generator]]></title>
      <url>%2F2016%2F12%2F04%2Fgenerator%2F</url>
      <content type="text"><![CDATA[generator实现的背后其实是协程的实践。它最大的特点就是可以允许开发人员可以使用同步调用的逻辑来实现异步操作，只要在需要等待的地方，使用yield语句即可。 koa的流程构建就是基于generator，了解generator可以很好地为学习koa打下基础。 下面就来详细了解generator。 1. 语法1.1 基本语法Generator中的语法，主要关注几点 function *：定义一个generator函数 yield：在generator函数的执行过程中起到中断/暂停执行函数的功能 next()：每次调用next()方法，generator函数都会执行到下一个yield语句或return语句，如果执行到yield语句的时候，如果yield语句跟着一个表达式，那么表达式的值将作为value被返回。 for..of：遍历所有的yield语句（return语句的返回值不会被输出） 来看一个简单的示例 123456789function * test () &#123; yield "Hello"; return "world";&#125;func = test();console.log(func.next()); console.log(func.next());console.log(func.next()); 执行结果为 可以看到对Generator函数的调用返回的实际上是一个遍历器，通过使用遍历器的next()方法来获得函数的输出（yield或return的值）。 从执行结果来看，遍历器返回一个对象，包含两个属性 value： yield后面跟着的表达式的值，或return的值 done ： 表示Generator函数的运行是否结束（false/true） 1.2 next()方法参数yield语句只是抛出value，而并非返回value值。如果想要yield语句有返回值，可以通过next()方法的传入一个参数，这个参数可以作为上一个yield语句的返回值。 12345678910111213141516function * f () &#123; var i = 0; while(true)&#123; var reset = yield i; console.log("reset = " + reset); if(reset)&#123; i = -1; &#125; i++; &#125;&#125;var g = f();console.log(g.next()); console.log(g.next());console.log(g.next(true)); 1.3 for-of 循环通过for-of来遍历yield语句，来让Generator函数自动执行每一步。 return语句的返回值不会被输出。 12345678910function * loop() &#123; for(let index = 0; index &lt; 6; index++)&#123; yield index; &#125; return -1;&#125;for(let i of loop())&#123; console.log(i);&#125; 1.4 yield *如果Generator函数内部需要调用另外一个generator函数，就需要使用yield *，示例如下： 1234567891011121314function * names () &#123; yield "foo"; yield "bar"; yield "zhang";&#125;function * say () &#123; yield * names(); yield "that's all the names";&#125;for(let name of say())&#123; console.log(name);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[es6系列-promise]]></title>
      <url>%2F2016%2F12%2F04%2Fpromise%2F</url>
      <content type="text"><![CDATA[在Promise之前，在js中的异步编程都是采用回调函数和事件的方式，但是这种编程方式在处理复杂业务的情况下，很容易出现callback hell(回调地狱)，使得代码很难被理解和维护。 Promise就是改善这种情形的异步编程的解决方案，它由社区最早提出和实现，es6将其写进了语言标准，统一了用法，并且提供了一个原生的对象Promise。 1. 理解Promise我们通过一个简单例子先来感受一下Promise。 1234567891011121314var p = new Promise(function (resolve, reject) &#123; // ... if(/* 异步操作成功 */)&#123; resolve(ret); &#125; else &#123; reject(error); &#125;&#125;);p.then(function (value) &#123; // 完成态&#125;, function (error) &#123; // 失败态&#125;); 我们需要关注的是 Promise的构造函数 resolve() ， reject() then() 1.1 Promise构造函数我们在通过Promise构造函数实例化一个对象时，会传递一个函数作为参数，那么这个函数有什么特点？ 答案就是在新建一个Promise后，这个函数会立即执行。 12345let promise = new Promise(function (reslove, reject) &#123; console.log('Promise');&#125;);console.log('end'); 执行结果如下： 可以看到是先输出了Promise，再输出了end。 1.2 resolve/reject在Promise中，对一个异步操作做出了抽象的定义，Promise操作只会处在3种状态的一种，他们之间的转化如图所示 注意，这种状态的改变只会出现从未完成态向完成态或失败态转化，不能逆反。完成态和失败态不能互相转化，而且，状态一旦转化，将不能更改。 只有异步操作的结果可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思是承诺，表示其他手段无法改变。 在声明一个Promise对象实例时，我们传入的匿名函数参数中： resolve就对应着完成态之后的操作 reject对应着失败态之后的操作 1.3 then()那么问题来了，then()方法有什么作用？resolve和reject又是从哪里传递过来的？ 其实这两个问题是一个问题，在实例化一个Promise对象之后，我们调用该对象实例的then()方法传递的两个参数中: 第一个参数（函数）对应着完成态的操作，也就是resolve 第二个参数（函数）对应着失败态的操作，也就是reject 那就是说，在Promise中是通过then()方法来指定处理异步操作结果的方法。 1.4 实际案例到这里我们明白了Promise的语法，也了解了Promise中函数是如何执行的，结合一个实际的案例，来加深对Promise的理解。 我们来实现一个异步加载图片的函数 1234567891011121314151617181920212223242526function loadImageAsync(url) &#123; return new Promise(function (reslove, reject) &#123; var img = new Image(); img.onload = function () &#123; reslove(); &#125; img.onerror = function () &#123; reject(); &#125; console.log("loading image"); img.src = url; &#125;);&#125;var loadImage1 = loadImageAsync("https://www.google.co.jp/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png");loadImage1.then(function success() &#123; console.log("success");&#125;, function fail() &#123; console.log("fail");&#125;);var loadImage2 = loadImageAsync("1.png");loadImage2.then(function success() &#123; console.log("success");&#125;, function fail() &#123; console.log("fail");&#125;); 我们在chrome中执行，先是传递一个有效的url，再传递一个无效的url，执行的效果为： 2. Promise进阶2.1 resolve/reject的参数reject函数的参数一般来说是Error对象的实例，而resolve函数的参数除了正常的值外，还可能是另一个Promise实例，表示异步操作的结果有可能是一个值，也有可能是另一个异步操作。 12345678var p1 = new Promise( function(resolve, reject) &#123; // ...&#125;);var p2 = new Promise( function(resolve, reject) &#123; // ... resolve(p1);&#125;); 代码分析：p1和p2都是Promise的实例，p2中的resolve方法将p1作为参数，即一个异步操作的结果是返回另一个异步操作。 注意，这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态，他们之间的关系是 举个例子 12345678910111213console.time('Promise example start')var p1 = new Promise( (resolve, reject) =&gt; &#123; setTimeout(() =&gt; resolve('hi'), 3000);&#125;);var p2 = new Promise( (resolve, reject) =&gt; &#123; setTimeout(() =&gt; resolve(p1), 10);&#125;);p2.then( ret =&gt; &#123; console.log(ret); console.timeEnd('Promise example end')&#125;); 我们在node环境下运行以上代码，执行结果为： 从执行时间可以看到，p2会等待p1的执行结果，然后再执行，从输出hi可以看到p1完成状态转变之后，传递给resolve(或者reject)的结果会传递给p2中的resolve。 2.2 then()从上面的例子，我们可以了解到then()方法是Promise实例的方法，即Promise.prototype上的，它的作用是为Promise实例添加状态改变时的回调函数，这个方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。 那么then()方法的返回值是什么？then方法会返回一个新的Promise实例（注意，不是原来那个Promise，原来那个Promise已经承诺过，此时继续then就需要新的承诺~~），这样的设计的好处就是可以使用链式写法。 还有一个点，就是链式中的then方法（第二个开始），它们的resolve中的参数是什么？答案就是前一个then()中resolve的return语句的返回值。 来一个示例： 12345678910111213var p1 = new Promise( (resolve, reject) =&gt; &#123; setTimeout(() =&gt; resolve('p1'), 10);&#125;);p1.then( ret =&gt; &#123; console.log(ret); return 'then1';&#125;).then( ret =&gt; &#123; console.log(ret); return 'then2';&#125;).then( ret =&gt; &#123; console.log(ret);&#125;); 在node环境下执行，执行结果为： 2.3 catch()错误处理catch()方法是Promise实例的方法，即Promise.prototype上的属性，它其实是.then(null, rejection)的简写，用于指定发生错误时的回调。 这个方法其实很简单，在这里并不想讨论它的使用，而是想讨论的是Promise中的错误的捕抓和处理。 2.3.1 Error对象的传递性Promise对象的Error对象具有冒泡性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获，示例代码如下： 12345678910111213141516var p = new Promise( (resolve, reject) =&gt; &#123; setTimeout(() =&gt; resolve('p1'), 10);&#125;);p.then( ret =&gt; &#123; console.log(ret); throw new Error('then1'); return 'then1';&#125;).then( ret =&gt; &#123; console.log(ret); throw new Error('then2'); return 'then2';&#125;).catch( err =&gt; &#123; // 可以捕抓到前面的出现的错误。 console.log(err.toString());&#125;); 执行结果如下 在第一个then中抛出了一个错误，在最后一个Promise对象中可以catch到这个错误。 因为有这种方便的错误处理机制，所以一般来说不要在then方法里面定义reject状态的回调函数， 而是使用catch方法 2.3.2 vs try/catch 跟传统的try/catch不同的是，如果没有使用catch方法指定错误处理回调函数，则Promise对象抛出的错误不会传递到外层代码（在chrome会报错） Node.js有一个unhandledRejection事件，专门监听未捕获的reject错误。以下代码就是在node环境下运行。 123456var p = new Promise((resolve, reject) =&gt; &#123; resolve(x + 2);&#125;);p.then( () =&gt; &#123; console.log('nothing');&#125;); 2.3.3 catch()的返回值没错，既然catch()是.then(null, rejection)的别名，那么catch()就会返回一个Promise对象，因此在后面还可以接着调用then方法，示例代码如下： 1234567891011var p = new Promise((resolve, reject) =&gt; &#123; resolve(x + 2);&#125;);p.then( () =&gt; &#123; console.log('nothing');&#125;).catch( err =&gt; &#123; console.log(err.toString()); return 'catch';&#125;).then( ret =&gt; &#123; console.log(ret);&#125;); 当出错时，catch会先处理之前的错误，然后通过return语句，将值继续传递给后一个then方法中。 如果没有报错，则跳过catch，示例如下： 123456789101112var p = new Promise((resolve, reject) =&gt; &#123; resolve('p');&#125;);p.then( ret =&gt; &#123; console.log(ret); return 'then1';&#125;).catch( err =&gt; &#123; console.log(err.toString()); return 'catch';&#125;).then( ret =&gt; &#123; console.log(ret);&#125;); 3. Promise对象方法3.1 Promise.all()Promise.all()方法用于将多个Promise实例，包装成一个新的Promise实例，例如 1var p = Promise.all([p1, p2, p3]); 新的Promise实例p的状态由p1, p2, p3决定： 当p1, p2, p3的状态都为完成态时，p为完成态。 p1, p2, p3中任一一个状态为失败态，则p为失败态。 3.2 Promise.race()Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。 1var p = Promise.race([p1, p2, p3]); 不同的是，只要p1, p2, p3中任意一个实例率先改变状态，则p的状态就跟着改变，而且状态由率先改变的实例决定。 12345678910var p = Promise.race([ new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve('p1'), 10000); &#125;), new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; reject(new Error('time out')), 10); &#125;)]);p.then( ret =&gt; console.log(ret)) .catch( err =&gt; console.log(err.toString())); 3.3 Promise.resolve()Promise.resolve()可以将现有的对象转为Promise对象。 1234var p = Promise.resolve('p');// 相当于var p = new Promise(resolve =&gt; resolve('p')); 比较有意思的是Promise.resolve()会根据参数类型进行相应的处理，分几种情况讨论。 3.3.1 Promise实例参数是一个Promise实例，那么Promise.resolve将不做任何处理，直接返回这个实例。 3.3.2 thenable对象参数是一个thenable对象，也就是说对象是具有then方法的对象，但不是一个Promise实例（就跟类数组和数组的关系一样），例如 12345678let thenable = &#123; then : function (resolve, reject) &#123; resolve(42); &#125;&#125;;let p = Promise.resolve(thenable);p.then( ret =&gt; console.log(ret)); // 42 Promise.resolve方法会将这个对象转为Promise对象，然后立即执行thenable对象中的then方法，因为例子中的thenable对象的then方法中执行了resolve，因此会输出结果42。 3.3.3 其他参数如果参数是一个原始值，或者不具有then方法的对象，则Promise.resolve方法返回一个新的Promise对象，状态为resolve，然后直接将该参数传递给resolve方法。 12var p = Promise.resolve("p");p.then( ret =&gt; console.log(ret)); // p 3.3.4 不带任何参数Promise.resolve方法不带参数时，会直接返回一个resolve状态的Promise对象。 需要注意的立即resolve的Promise对象，是在本轮事件循环的结束时，而不是下一轮事件循环的开始执行。示例代码： 1234setTimeout(() =&gt; console.log('3'), 0);var p = Promise.resolve();p.then(() =&gt; console.log('2'));console.log('1'); 输出结果为： 3.4 Promise.reject()Promise.reject()返回一个新的Promise实例，该实例的状态为rejected，对于传入的参数的处理跟Promise.resolve类似，就是状态都为rejected。 4. 两个实用的方法4.1 done()Promise对象的回调链，不管以then方法或者catch方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到，因为Promise内部的错误不会冒泡到全局，因此，我们可以提供一个done方法，总是处理回调链的尾端，保证抛出任何可能出现的错误。 这个代码的实现非常简单 123456789101112131415161718192021222324Promise.prototype.done = function (resolve, reject) &#123; this.then(resolve, reject) .catch( function (reason) &#123; // 抛出一个全局错误 setTimeout( () =&gt; &#123; throw reason &#125;, 0); &#125;);&#125;// 使用示例var p = new Promise( (resolve, reject) =&gt; &#123; resolve('p');&#125;);p.then(ret =&gt; &#123; console.log(ret); return 'then1';&#125;).catch( err =&gt; &#123; console.log(err.toString());&#125;).then( ret =&gt; &#123; console.log(ret); return 'then2';&#125;).then( ret =&gt; &#123; console.log(ret); x + 2;&#125;).done(); 这里为什么可以在全局抛出一个错误？原因就是setTimeout中的回调函数是在全局作用域中执行的，因此抛出的错误就是在全局作用域上。 4.2 finally()finally方法用于指定不管Promise对象最后的状态如何，都会执行的操作，它与done方法最大的区别就是，它接受一个普通函数作为参数，该函数不管怎么样都必须执行。 1234567Promise.prototype.finally = function (callback) &#123; let P = this.constructor; return this.then( ret =&gt; P.resolve(callback()).then( () =&gt; ret), err =&gt; P.resolve(callback()).then( () =&gt; &#123;throw reason &#125;) );&#125;; 5. Promise的优劣势从上面几个小节综合来看，可以看到Promise其实就是做了一件事情，那就是对异步操作进行了封装，然后可以将异步操作以同步的流程表达出来，避免了层层嵌套的回调函数，同时提供统一的接口，使得控制异步操作更加容易。 但是，Promise也有一些缺点： 无法取消Promise，一旦新建它就会立即执行，无法中途取消。 如果不设置回调函数，Promise内部的错误不会反应到外部。 当处于未完成态时，无法得知目前进展到哪一个阶段。 6. Promise与generator的结合使用Generator函数来管理流程，遇到异步操作的时候，通常返回一个Promise对象。 123456789101112131415161718192021222324252627282930function getFoo() &#123; return new Promise( resolve =&gt; resolve('foo'));&#125;var g = function * () &#123; try &#123; var foo = yield getFoo(); console.log(foo); &#125; catch(e)&#123;&#125;&#125;function run(generator) &#123; var it = generator(); function go(result) &#123; if(result.done) return result.value; // 默认value是一个Promise，其实这里应该做判断的 if(!(result.value instanceof Promise))&#123; throw Error('yield must follow an instanceof Promise'); &#125; return result.value.then( ret =&gt; go(it.next(ret)) ).catch(err =&gt; go(it.throw(err))); &#125; go(it.next());&#125;run(g); 上面代码的Generator函数g之中，有一个异步操作getFoo，它返回的就是一个Promise对象。函数run用来处理这个Promise对象，并调用下一个next方法。 7. 来源 ECMAScript 6入门-阮一峰]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[es6系列-class]]></title>
      <url>%2F2016%2F12%2F04%2Fclass%2F</url>
      <content type="text"><![CDATA[在js中，class一直是一个保留的关键字，在es6中实现了class的功能，用于声明定义一个类（注意，其实还是基于原型继承的，class实现可以说只是语法糖而已）。 下面就来看看class的用法和需要注意的地方。 1. 基本语法使用class关键字声明一个类的基本结构 123456789101112class Person &#123; // 构造函数 constructor (name) &#123; // 属性初始化 this.name = name; &#125; // 成员方法 sayName () &#123; console.log(this.name); &#125;&#125; 使用示例 12var p = new Person("zhang"); // 实际上就是调用构造函数p.sayName(); // zhang 3. 静态方法使用static可以声明一个静态方法 1234567891011121314151617class Person &#123; // 构造函数 constructor (name) &#123; // 属性初始化 this.name = name; &#125; // 静态方法 static sayHi () &#123; console.log("Hi~"); &#125; // 成员方法 sayName () &#123; console.log(this.name); &#125;&#125; 使用示例，其实所谓的静态方法，就是Person函数的属性 1Person.sayHi(); // Hi~ 4. 继承使用extends关键字可以实现继承 1234567891011121314151617181920212223242526class Person &#123; // 构造函数 constructor (name) &#123; // 属性初始化 this.name = name; &#125; // 成员方法 sayName () &#123; console.log(this.name); &#125;&#125;class Student extends Person &#123; contructor (name, school) &#123; // 调用父类的构造函数，Person.call(this, name); super(name); this.school = school(); &#125; // override 成员方法 sayName () &#123; // 相当于Person.prototype.sayName.call(this); super().sayName(); console.log("i'am from " + this.school); &#125;&#125; 使用示例 12var s = new Student("zhang", "scut");s.sayName(); // zhang i'am from scut 注意到在代码中出现了两次super，两次super其实的代表对象的是不一样的 在构造函数中，super相当于Person 在成员函数中，super相当于Person.prototype 5. setter/getter关于setter/getter，有不少坑，我们通过一个例子来详细说明。 5.1 setter/getter的调用执行时机12345678910111213141516class Person &#123; constructor (name, age) &#123; this.name = name; this.age = age; &#125; set name (name) &#123; console.log("setter"); this.name = name; &#125; get name () &#123; console.log("getter"); return this.name; &#125;&#125;var p = new Person("zhang", 25); 很快，我们就会发现代码报错了 这是因为，在构造函数中执行this.name=name的时候，就会去调用set name，在set name方法中，我们又执行this.name = name，进行无限递归，最后导致栈溢出(RangeError)。 我们稍作修改，让这个代码可以正常执行，达到我们想要的效果。 12345678910111213141516171819202122class Person &#123; constructor (name, age) &#123; this.name = name; this.age = age; &#125; set name (name) &#123; console.log("setter"); this._name = name; &#125; get name () &#123; console.log("getter"); return this._name; &#125; // 加一个成员方法 sayName () &#123; console.log(this.name); &#125;&#125;var p = new Person("zhang", 25); p.sayName(); 执行结果为 到这里就可以明白了，原来只要this.name中的属性名和set name/get name后面的name一致，对this.name就会调用setter/getter，也就是说setter/getter是hook函数，而真实的存储变量是_name，我们可以在代码中直接获取它。 12345678910111213141516171819202122class Person &#123; constructor (name, age) &#123; this.name = name; this.age = age; &#125; set name (name) &#123; console.log("setter"); this._name = name; &#125; get name () &#123; console.log("getter"); return this._name; &#125; // 加一个成员方法 sayName () &#123; console.log(this.name); &#125;&#125;var p = new Person("zhang", 25); console.log(p._name); // "zhang" 执行结果为 注意到结果并没有执行getter，因为我们直接访问了p._name，而不是p.name 5.2 只有getter定义只读属性当一个属性只有getter没有setter的时候，我们是无法进行赋值操作的（第一次初始化也不行），这一点也是相当地坑。例如 123456789101112class Person &#123; constructor (name) &#123; this.name = name; &#125; // 只有getter get name () &#123; console.log("getter"); return this.name; &#125;&#125;var p = new Person("zhang"); 执行结果为 当没有getter和setter时，就可以正常读写属性 6. 私有属性在上面的例子其实已经可以看到，即使有setter/getter的情况下，还是无法对属性进行封装，我们还是可以通过对象直接访问到该属性p._name，那么如何来实现私有的属性？ 6.1 构造函数 + 闭包12345678910111213141516171819202122class Person &#123; constructor (name) &#123; Object.assign(this, &#123; getName() &#123; console.log("getter") return name; &#125;, setName (othername) &#123; console.log("setter") name = othername; &#125; &#125;); &#125; sayName () &#123; console.log(this.getName()); &#125;&#125;var p = new Person("zhang");p.sayName(); // zhangconsole.log(p.name); // undefined 6.2 WeakMapWeakMap详解 6.3 Symbol + 闭包Symbol详解 7. 完整示例]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[websocket]]></title>
      <url>%2F2016%2F12%2F02%2Fwebsocket%2F</url>
      <content type="text"><![CDATA[websocket的出现是为了弥补http的不足，如今这项技术已被广泛应用于我们熟悉的网站，例如github、stackoverflow等等。 1. 概述 WebSocket是Web应用程序的传输协议，它提供了双向的、按序到达的数据流。 高层的协议能够在WebSocket上运行。 作为Web的一部分，WebSocket连接的是URL。 2. WebSocket握手 为了建立WebSocket通信，客户端和服务器在初始握手时，将HTTP协议升级到了WebSocket协议。 从客户端到服务器 GET /chat HTTP/1.1 Host: example.com Connection: Upgrade Sec-WebSocket-Protocol: Sample Upgrade: websocket Sec-WebSocket-Version: 13 Sec-WebSocket-Key: ..... Origin: http://example.com [8-byte security key] 从服务器到客户端 HTTP/1.1 101 WebSocket Protocol Handshake Upgrade: websocket Connection: Upgrade Sec-WebSocket-Accept: ... WebSocket-Protocol: sample 一旦连接成功，就可以在全双工模式下在客户端和服务器之间来回传送Websocket消息。这就意味着，在同一时间、任何方向，都可以全双工发送基于文本的消息。在网络中，每个消息以Ox00字节开头，以OxFF结尾，中间数据采用UTF-8编码格式。 3. WebSocket API采用Websocket API的流程 创建Socket 1var socket = new WebSocket('ws://www.example.com:1234/resource'); 注册事件处理程序 123456789socket.onopen = function(e)&#123;/*socket已经连接*/&#125;socket.onclose = function(e)&#123;/*socket已经关闭*/&#125;socket.onerror = function(e)&#123;/*出错了*/&#125;socket.onmessage = function(e)&#123; var message = e.data; /*服务器发送一条消息*/&#125; 发送数据 1socket.send('Hello World'); 关闭Socket 1socket.close(); 4. 搭建简易实验环境基于node的Socket.IO来搭建服务器端。 Socket.IO可以接收所有与服务器端相连接的客户端发送的消息，也可以向这些客户端发送消息。它可以实现以下几种通信方式： HTML5的Websocket 在Flash中使用WebSocket通信 XHR轮询 JSONP轮询 Forever Iframe 安装 npm install socket.io 参考 《HTML5程序设计》 《JavaScript权威指南》]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[XMLHttpRequest详解]]></title>
      <url>%2F2016%2F12%2F02%2Fxhr%2F</url>
      <content type="text"><![CDATA[XMLHttpRequest是一个JavaScript对象，它最初由微软设计(一开始的实现并非一个JavaScript对象，因此又带来了”喜闻乐见”的兼容性问题)，随后被Mozilla、Apple和Google采纳。如今，该对象已经被W3C组织标准化。 1var xhr = new XMLHttpRequest(); 通过它，你可以很容易的取回一个URL上的资源数据。尽管名字里有XML， 但XMLHttpRequest可以取回所有类型的数据资源（其实不然，现在的XHR有两个版本了，旧版本的支持的数据资源并不多），并不局限于XML。而且除了HTTP ,它还支持file和ftp协议。 XMLHttpRequest Level 2 在HTML5的概念形成后，W3C开始标准化这个接口，2008年2月，提出了XMLHttpRequest Level 2草案。 这个XMLHttpRequest的新版本，提出了很多有用的新功能。 兼容性查阅 1. State属性readyState表示了请求的五种状态 值 状态 描述 0 UNSET(未打开) open()方法还未被调用 1 OPENED(未发送) send()方法还未被调用 2 HEADERS_RECEIVED(已获得响应头) send()方法已经被调用，且响应头和响应状态已经返回 3 LOADING(正在下载响应体) 响应体下载中，responseText已经获取了部分数据 4 DONE(请求完成) 整个请求过程已经完毕 当readyState属性改变时，会调用onreadyStateChange 12345xhr.onreadyStateChange = function () &#123; if(this.readyState == 4)&#123; // 请求结束 &#125;&#125; 2. 发送请求过程2.1 open()初始化一个请求这个方法的参数可以为 method: HTTP方法，有”GET”,”POST”,”HEAD”,”DELETE”,”PUT” url: 该请求所要访问的URL async: 默认为true，即异步执行，如果为false，则会阻塞直到数据返回 user: 为授权使用，默认为空 password: 为授权使用，默认为空 注意此时还没有发送请求，只是做初始化的工作而已。 1xhr.open("POST","www.example.com"); 2.2 setRequestHeader()设置请求头在调用open()方法初始化一个请求之后，我们可以给HTTP请求头赋值。不过这个方法是受限的，有一部分请求头是不能被设置的。 – – – Accept-Charset Content-Transfer-Encoding TE Accpet-Encoding Date Trailer Connection Expect Transfer-Encoding Content-Length Host Upgrade Cookie Keep-Alive User-Agent Cookie2 Referer Via 12// 表单数据的编码类型xhr.setRequestHeader("Content-Type","application/x-www-form-urlencoded"); 2.3 timeout[XHR 2]超时处理网络任务通常是不可靠的，所以要考虑超时的问题。可以通过设置timeout属性来设置HTTP请求的时限，单位是毫秒。 如果请求超过了时限，就自动停止HTTP请求，可以通过timeout事件来指定回调函数。 1234xhr.timeout = 3000;xhr.ontimeout = function ()&#123; // 超时处理&#125; 2.4 withCredentials[XHR 2]跨域withCredentials为true时，可以进行跨域请求，反之，则不行。 1xhr.withCredentials = true; 这个属性也可以用来检测浏览器是否支持XHR 2 123function isSupport() &#123; return new XMLHttpRequest().withCredentials ? true : false;&#125; 关于跨域的实现其实是依赖了新增的HTTP请求头，需要服务器的支持。在浏览器端发送请求的时候，加上一个Origin的头部信息，服务器可以根据这个头部信息来决定是否响应，如果服务器认为这个请求可以接受，就可以在Access-Control-Allow-Origin头部中回发相同的源信息。如果没有这个头部，或者源信息不匹配，浏览器就会驳回请求。 请求和响应都不包含cookie信息 2.5 upload[XHR 2]跟踪上传事件可以在upload上添加一个事件监听来跟踪上传的过程，upload有一个progress事件，每当进度有变化的时候，就会触发。 12xhr.upload.onprogress = function (event) &#123;&#125; 2.6 发送请求send(data)发送请求，如果是异步模式（默认），该方法会立刻返回，相反，如果是同步模式，则直到请求的响应完全接受以后，该方法才会返回。 该方法可以发送多种类型的数据 1234send(null); // get 请求的情况send(Blob data); // postsend(FormData data);// postsend(ArrayBuffer data);// post 2.7 中止请求[XHR 2]调用abort()，如果请求已经被发送，则立刻中止请求。 1xhr.abort(); 3. 获取响应3.1 获取http请求的状态可以通过status来获取http请求的状态码，statusText来获取状态的描述。一般来说，会结合readyState和HTTP状态码来判断一个xhr请求是否成功返回 1234567xhr.onreadyStateChange = function () &#123; if(this.readyState == 4)&#123; if(this.status == 200)&#123; // 成功返回 &#125; &#125;&#125; 3.2 获得响应头通过getResponseHeader()/getAllResponeseHeader()能查询响应头，但是并非所有的响应头都可以获取的到，例如cookie。 3.3 overrideMimeType()[XHR 2]重写服务器返回的MIME类型这个方法会强迫xhr对象将响应当作指定的类型来进行处理，不过必须在send()方法之前调用这个方法。 123xhr.open("get","");xhr.overrideMimeType("text/xml");xhr.send(null); 这样，即使服务器返回的MIME类型是text/plain，xhr还是会将响应当作XML进行处理。 3.3 指定服务器返回的MIME类型设置responseType能够改变响应类型，通知服务器客户端期待的响应格式 值 对应的数据类型 “” 字符串（默认值） “arraybuffer” ArrayBuffer “document” Document “json” JSON “text” 字符串 在指定了responseType之后，就必须使用response来接收响应实体的类型。 1var arrayBuffer = xhr.response; 3.4 [常用]响应体内容responseText最常用的接收服务器响应的内容 3.5 responseXML 响应体内容接收服务器响应的xml内容，如果服务器返回的MIME类型是text\plain的话，responseXML为null 4. 进度事件[XHR 2]Progress Events定义了与客户端通信有关的事件，共有6个进度事件 loadstart: 在接收到响应数据的第一个字节时触发 progress: 在接收响应期间持续不断地触发 error: 在请求发生错误时触发 abort: 在调用abort()方法而终止连接时触发 load: 在接收到完整的响应数据时触发 loadend: 在通信完成或触发error、abort或load事件后触发 4.1 progress事件onprogress事件处理程序会接收到一个event对象，其target属性是XHR对象，此外还包含3个额外的属性 lengthComputable: 表示进度信息是否可用的布尔值 position: 表示已经接收的字节数 totalSize: 根据Content-length响应头确定的预期字节数 12345xhr.onprogress = function(event) &#123; if(event.lengthComputabel) &#123; var percent = event.position / event.totalSize; &#125;&#125; 5. 实现首先是获取xhr对象，这一点主要是在IE中比较麻烦 12345678910111213function createXhr() &#123; var xhr; if(window.XMLHttpRequest)&#123; // 非IE return new XMLHttpRequest(); &#125; else if (window.ActiveXObject) &#123; // IE var versions = [ "MSXML2.XMLHTTP", "MSXML2.XMLHTTP.6.0","MSXML2.XMLHTTP.3.0"]; for (var i = 0; i &lt; versions.length; i++) try &#123; xhr = new ActiveXObject(version[i]) if(xhr)break; &#125;catch (e) &#123;&#125;; &#125;&#125; 结合上述内容，我们来进行封装，这里利用了一个技巧，叫惰性加载机制，在其他的章节中有详细的介绍。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126(function ()&#123; var ajax = &#123; _createXhr : function () &#123; var xhr,curVersion; if(window.XMLHttpRequest)&#123; _createXhr = function () &#123; return new XMLHttpRequest(); &#125; xhr = new XMLHttpRequest(); &#125; else if (window.ActiveXObject) &#123; var versions = [ "MSXML2.XMLHTTP", "MSXML2.XMLHTTP.6.0","MSXML2.XMLHTTP.3.0"]; for (var i = 0; i &lt; versions.length; i++) try &#123; xhr = new ActiveXObject(version[i]) if(xhr)&#123; curVersion = version[i]; _createXhr = function () &#123; return new ActiveXObject(curVersion); &#125; break; &#125; &#125;catch (e) &#123;&#125;; &#125; if(!xhr) &#123; throw new Error("fail to create XHR"); &#125; return xhr; &#125;, _serialize : function(data) &#123; if(typeof data == "object") &#123; var p = []; for(var key in data)&#123; p.push(encodeURIComponent(key) + "=" + encodeURIComponent(data[key])); &#125; return p.join("&amp;"); &#125; else if (typeof data == "string")&#123; return data; &#125; else &#123; throw new Error("fail to serialize parameters"); &#125; &#125;, _get : function(params,xhr) &#123; // get请求 var url = params.url; if(params.data) &#123; url = url.indexOf("?") &gt; 0 ? url : (url + "?"); url += this._serialize(params.data); &#125; xhr.open("get",url); xhr.send(null); &#125;, _post : function(params,xhr) &#123;// post请求 var url = params.url; if(params.data) &#123; var data = this._serialize(params.data); &#125; xhr.open("post",url); // 增加请求头 xhr.setRequestHeader("Content-Type", params.contentType || "application/x-www-form-urlencoded"); xhr.send(data); &#125;, send : function (params)&#123; if (!params.url) &#123; throw new Error("invalid parameters"); &#125; var requestType = params.requestType || "GET"; var timeout = params.timeout || 60000; var callback = params.callback || function()&#123;&#125;; var xhr = ajax._createXhr(); // 超时错误，可以使用timeout和ontimeout， // 这里使用定时器来实现 if("timeout" in xhr)&#123; xhr.timeout = timeout; xhr.ontimeout = function () &#123; callback(&#123;msg:"timeout"&#125;); &#125; &#125; else &#123; var timer = setTimeout(function () &#123; xhr.abort(); callback(&#123;msg:"timeout"&#125;); &#125;,timeout) &#125; // 正常返回 xhr.onreadystateChange = function () &#123; if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123; timer &amp;&amp; clearTimeout(timer); var ret = xhr.responseText; try &#123; ret = typeof JSON.parse == "function"? JSON.parse(ret) : ret; &#125;catch(_)&#123;&#125;; callback(ret); &#125; &#125; // 请求错误 xhr.onerror = function () &#123; timer &amp;&amp; clearTimeout(timer); callback(&#123;msg:"error"&#125;); &#125; // 开启跨域 if("withCredential" in xhr)&#123; xhr.withCredentials = true; &#125; // 处理参数 requestType = requestType.toUpperCase(); switch(requestType)&#123; // 之后可以补充多个请求方法 case "GET" : ajax._get(params, xhr); break; case "POST" : ajax._post(params, xhr); break; &#125; &#125; &#125;; window.ajax = ajax;&#125;)(); 6. 参考 MDN W3C标准 《JavaScript权威指南》 脚本化HTTP XMLHttpRequest Level 2 使用指南 《JavaScript高级程序设计》]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[图像ping技术]]></title>
      <url>%2F2016%2F12%2F02%2Fping%2F</url>
      <content type="text"><![CDATA[图像Ping是使用\标签来进行跨域请求的技术，这种技术有两个特点： img标签的src是可以跨域的，这是实现的基础 请求只支持get请求（src的限制） 请求只能是单向的，即客户端-&gt;服务器，因为我们无法访问服务器的响应文本 服务器可以响应任意内容，通常是像素或204响应（即服务器成功处理 ，但没有返回任何内容） 1. 实现它的实现其实非常简单，就是通过一个Image实例，然后将onload和onerror事件处理程序指定为同一个函数，这样无论是什么响应，只要请求完成，就能得到通知。 123456789;(function()&#123; function ping(url)&#123; var img = new Image(); img.onload = img.onerror = function() &#123; console.log("done"); &#125; img.src = url; &#125;&#125;)() 2. 适用场景由于这种请求技术的单向特点，因此这项技术经常运用了统计上报的功能，这也是在线广告跟踪浏览量的主要方式。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jsonp的原理与实现]]></title>
      <url>%2F2016%2F12%2F02%2Fjsonp%2F</url>
      <content type="text"><![CDATA[jsonp是一种跨域通信的手段，它的原理其实很简单： 首先是利用script标签的src属性来实现跨域。 通过将前端方法作为参数传递到服务器端，然后由服务器端注入参数之后再返回，实现服务器端向客户端通信。 由于使用script标签的src属性，因此只支持get方法 下面详细讲讲如何实现jsonp。 1. 实现流程 设定一个script标签 1&lt;script src="http://jsonp.js?callback=xxx"&gt;&lt;/script&gt; callback定义了一个函数名，而远程服务端通过调用指定的函数并传入参数来实现传递参数，将fn(response)传递回客户端 12$callback = !empty($_GET['callback']) ? $_GET['callback'] : 'callback';echo $callback.'(.json_encode($data).)'; 客户端接收到返回的js脚本，开始解析和执行fn(response) 2. jsonp简单实现一个简单的jsonp实现，其实就是拼接url，然后将动态添加一个script元素到头部。 123456function jsonp(req)&#123; var script = document.createElement('script'); var url = req.url + '?callback=' + req.callback.name; script.src = url; document.getElementsByTagName('head')[0].appendChild(script); &#125; 前端js示例 1234567function hello(res)&#123; alert('hello ' + res.data);&#125;jsonp(&#123; url : '', callback : hello &#125;); 服务器端代码 1234567891011121314151617181920var http = require('http');var urllib = require('url');var port = 8080;var data = &#123;'data':'world'&#125;;http.createServer(function(req,res)&#123; var params = urllib.parse(req.url,true); if(params.query.callback)&#123; console.log(params.query.callback); //jsonp var str = params.query.callback + '(' + JSON.stringify(data) + ')'; res.end(str); &#125; else &#123; res.end(); &#125; &#125;).listen(port,function()&#123; console.log('jsonp server is on');&#125;); 然而，这个实现虽然简单，但有一些不足的地方： 我们传递的回调必须是一个全局方法，我们都知道要尽量减少全局的方法。 需要加入一些参数校验，确保接口可以正常执行。 3. 可靠的jsonp实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546(function (global) &#123; var id = 0, container = document.getElementsByTagName("head")[0]; function jsonp(options) &#123; if(!options || !options.url) return; var scriptNode = document.createElement("script"), data = options.data || &#123;&#125;, url = options.url, callback = options.callback, fnName = "jsonp" + id++; // 添加回调函数 data["callback"] = fnName; // 拼接url var params = []; for (var key in data) &#123; params.push(encodeURIComponent(key) + "=" + encodeURIComponent(data[key])); &#125; url = url.indexOf("?") &gt; 0 ? (url + "&amp;") : (url + "?"); url += params.join("&amp;"); scriptNode.src = url; // 传递的是一个匿名的回调函数，要执行的话，暴露为一个全局方法 global[fnName] = function (ret) &#123; callback &amp;&amp; callback(ret); container.removeChild(scriptNode); delete global[fnName]; &#125; // 出错处理 scriptNode.onerror = function () &#123; callback &amp;&amp; callback(&#123;error:"error"&#125;); container.removeChild(scriptNode); global[fnName] &amp;&amp; delete global[fnName]; &#125; scriptNode.type = "text/javascript"; container.appendChild(scriptNode) &#125; global.jsonp = jsonp;&#125;)(this); 使用示例 1234567jsonp(&#123; url : "www.example.com", data : &#123;id : 1&#125;, callback : function (ret) &#123; console.log(ret); &#125;&#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[json的解析与序列化]]></title>
      <url>%2F2016%2F12%2F02%2Fjson%2F</url>
      <content type="text"><![CDATA[JSON是一种用于网络通信的轻量级的数据格式，它比XML更加简洁。JSON是JavaScript的一个严格的子集，但是JSON并不从属于JavaScript。 在ECMASCript 5对解析JSON的行为进行规范，定义了全局对象JSON，这个对象有两个方法 stringify(): 把一个JavaScript对象序列化为一个JSON字符串 parse(): 将一个JSON字符串解析为原生的JavaScript值 下面详解。 1. 解析与序列化1.1 eval()早期一般都是采用eval()来进行JSON解析，但是在旧版本的浏览器中，使用eval()对JSON数据结构求值存在风险，因为可能会执行一些恶意的代码。 1.2 stringify()stringify()可以接收另外两个参数，可以用于以不同的方式序列化JavaScript对象。 第一个参数是过滤器，可以是一个数组，也可以是一个函数 可以通过数组来指定序列化的属性 1JSON.stringify(book, ["title","edition"]); 通过函数也可以进行过滤 12345JSON.stringify(book, function(key, value)&#123; switch(key)&#123; // 进行处理 &#125;&#125;); 第二个参数是一个选项，表示是否在JSON字符串中保留缩进 例如在每个级别缩进4个空格 1JSON.stringify(book, null, 4); 1.3 toJSON()在有些情况下，可以通过对象上调用toJSON()方法，返回其自身的JSON数据格式，也可以为任何对象添加toJSON()方法。 例如Date对象就有一个toJSON方法，能够将JavaScript的Date对象自动转换成ISO日期字符串。 1.4 parse()parse()还可以再接收一个函数作为参数，对每个键值进行过滤（又叫做还原）。在函数中返回undefined，则表示从结果中删除响应的键，如果返回其他值，则将该值插入到结果中。 例如将日期字符串转换为Date对象时，经常要用到 1234567JSON.parse(jsonText, function(key, value)&#123; if(key == "releaseDate") &#123; return new Date(value); &#125; else &#123; return value; &#125;&#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTTP基础知识]]></title>
      <url>%2F2016%2F11%2F30%2Fhttp%2F</url>
      <content type="text"><![CDATA[HTTP(Hyper Text Transfer Protocol)，即超文本传输协议，目前网页传输的通用协议。 而在前端的开发中，我们需要了解哪些http的知识? 1. HTTP的特点 支持客户/服务器模式 简单快速 客户向服务器请求服务时，只需传送请求方法和路径 灵活 HTTP允许传输任意类型的数据对象，传输的类型有Content-Type加以标记 无连接 无连接的含义是限制每次连接只处理一个请求，服务器处理完客户端的请求，并且收到客户端的应答后，即断开连接。采用这种方式可以节省传输时间。 无状态 HTTP协议是无状态的。无状态是指协议对于事务处理没有记忆能力，缺少状态意味着后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息的时候，它的应答会较快。 2. HTTP数据组成部分 message-header http header消息通常分为4个部分 general header request header response header entity header 由于之间的界限不是很明确，大致分为Request和Response两个部分 message-body 3. HTTP请求http请求由3个部分组成 请求行 消息报头（在HTTP Header详述） 请求正文 其中，请求行的格式： Method Request-URI HTTP-Version CRLF（换行或回车） Method（请求方法），有以下几种 请求方法 说明 GET 请求获取Request-URI所标识的资源 POST 在Request-URI所标识的资源后附加新的数据 HEAD 请求获取由Request-URI所标识的资源的响应消息报头 PUT 请求服务器存储一个资源，并用Request-URI作为标识 DELETE 请求服务器删除Request-URI所标识的资源 TRACE 请求服务器回送收到的请求信息，主要用于测试或诊断 CONNECT 保留 OPTIONS 请求查询服务器的性能，或者查询与资源相关的选项和需求 Request-URI（统一资源标识符） HTTP-Version：目前有HTTP1.0/HTTP1.1，HTTP2.0也在实践中了 4. HTTP响应http响应也是3个部分组成： 状态行 消息报头（在HTTP Header详述） 响应正文 状态行的格式为： HTTP-Version Status-Code Reason-Phrase CRLF HTTP-Version Status-Code（状态代码） 响应类别 说明 1xx 指示信息，表示请求已接收，继续处理 2xx 成功，表示请求已被成功接收、理解、接受 3xx 重定向，要完成请求必须更进一步的操作 4xx 客户端错误，请求有语法错误或请求无法实现 5xx 服务器端错误，服务器未能实现合法的请求 常见的状态码 状态码 说明 200 OK 客户端请求成功 304 OK 从缓存中读取数据 401 Unauthorized 请求未经授权 403 Forbidden 服务器收到请求，但是拒绝服务 404 Not Found 请求资源不存在 500 Internal Server Error 服务器发送不可预期的错误 503 Server Unavaliable 服务器当前不能处理客户端的请求 Reason-Phrase（状态代码的文本描述） 5. HTTP头部详解5.1 Request的头部 header 说明 示例 Accept 指定客户端能够接收的内容类型 Accept:text/plain,text/html Accept-Charset 浏览器可以接收的字符编码集 Accept-Charset:iso-8889-5 Accept-Encoding 指定浏览器可以支持的web服务器返回的内容压缩编码类型 Accept-Encoding: compress,gzip Accept-Language 浏览器可接受的语言 Accept-Language:en,zh Accept-Ranges 可以请求网页实体的一个或多个子范围字段 Accept-Ranges:bytes Authrization HTTP授权的授权证书 Authorization:Basic jpvcGVuIHNlc2FtZQ== Cache-Control 指定请求和响应遵循的缓存机制 Cache-Control:no-cache Connection 表示是否需要持久连接（HTTP1.1默认） Connection:close Cookie 发送请求时，会将请求域名下的所有Cookie值一起发送给服务器 Cookie:$Version=1;Skin=new; Content-Length 请求内容长度 Content-Length:348 Content-Type 请求的与实体对应的MIME信息 Content-Type:application/x-www-form-urlencoded Date 请求发送的时间 Date:Tue,15,Nov 2015 08:12:31 GMT Expect 请求的特定的服务器行为 Expect:100-Continue From 发出请求的用户的Email From:user@email.com Host 指定请求的服务器域名和端口号 Host:www.example.com If-Match 只有请求内容与实体相匹配才有效 If-Match: “737060cd8c284d8af7ad3082f209582d” If-Modified-Since 如果请求的部分在指定时间之后被修改则请求成，未被修改则返回304 If-Modified-Since: Sat,29 Oct 2010 19:43:32 GMT If-None-Match 如果内容未改变返回304，参数为服务器之前发送的Etag，与服务器回应的Etag比较判断是否改变 If-Node-Match: “737060cd8c284d8af7ad3082f209582d” If-Range 如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体，参数也为Etag If-Range: “737060cd8c284d8af7ad3082f209582d” If-Unmodified-Since 只在实体在指定时间之后未被修改才请求成功 If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT Max-Forwards 限制信息通过代理和网关传送的时间 Max-Forwards:10 Pragma 用来包含实现特定的指令 Pragma:no-cache Proxy-Authorization 连接到代理的授权证书 Proxy-Authorization:Basic jpvcGVuIHNlc2FtZQ== Range 只请求实体的一部分，指定范围 Range:bytes=500-999 Referer 先前网页的地址，当前请求网页紧随其后 Referer:www.example.com/home TE 客户端愿意接受的传输编码，并通知服务器接收尾加头信息 TE:trailers,deflate;q=0.5 Upgrade 向服务器指定某种传输协议以便服务器进行转换 Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11 User-Agent User-Agent的内容包含发出请求的用户信息 User-Agent: Mozilla/5.0 (Linux; X11) Via 通知中间网关或代理服务器地址，通信协议 Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1) Warning 关于消息实体的警告信息 Warn：Warn: 199 Miscellaneous warning 5.2 Response的头部 header 说明 示例 Accept 指定客户端能够接收的内容类型 Accept:text/plain,text/html Accept-Charset 浏览器可以接收的字符编码集 Accept-Charset:iso-8889-5 Accept-Encoding 指定浏览器可以支持的web服务器返回的内容压缩编码类型 Accept-Encoding: compress,gzip Accept-Language 浏览器可接受的语言 Accept-Language:en,zh Accept-Ranges 可以请求网页实体的一个或多个子范围字段 Accept-Ranges:bytes Authrization HTTP授权的授权证书 Authorization:Basic jpvcGVuIHNlc2FtZQ== Cache-Control 指定请求和响应遵循的缓存机制 Cache-Control:no-cache Connection 表示是否需要持久连接（HTTP1.1默认） Connection:close Cookie 发送请求时，会将请求域名下的所有Cookie值一起发送给服务器 Cookie:$Version=1;Skin=new; Content-Length 请求内容长度 Content-Length:348 Content-Type 请求的与实体对应的MIME信息 Content-Type:application/x-www-form-urlencoded Date 请求发送的时间 Date:Tue,15,Nov 2015 08:12:31 GMT Expect 请求的特定的服务器行为 Expect:100-Continue From 发出请求的用户的Email From:user@email.com Host 指定请求的服务器域名和端口号 Host:www.example.com If-Match 只有请求内容与实体相匹配才有效 If-Match: “737060cd8c284d8af7ad3082f209582d” If-Modified-Since 如果请求的部分在指定时间之后被修改则请求成，未被修改则返回304 If-Modified-Since: Sat,29 Oct 2010 19:43:32 GMT If-None-Match 如果内容未改变返回304，参数为服务器之前发送的Etag，与服务器回应的Etag比较判断是否改变 If-Node-Match: “737060cd8c284d8af7ad3082f209582d” If-Range 如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体，参数也为Etag If-Range: “737060cd8c284d8af7ad3082f209582d” If-Unmodified-Since 只在实体在指定时间之后未被修改才请求成功 If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT Max-Forwards 限制信息通过代理和网关传送的时间 Max-Forwards:10 Pragma 用来包含实现特定的指令 Pragma:no-cache Proxy-Authorization 连接到代理的授权证书 Proxy-Authorization:Basic jpvcGVuIHNlc2FtZQ== Range 只请求实体的一部分，指定范围 Range:bytes=500-999 Referer 先前网页的地址，当前请求网页紧随其后 Referer:www.example.com/home TE 客户端愿意接受的传输编码，并通知服务器接收尾加头信息 TE:trailers,deflate;q=0.5 Upgrade 向服务器指定某种传输协议以便服务器进行转换 Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11 User-Agent User-Agent的内容包含发出请求的用户信息 User-Agent: Mozilla/5.0 (Linux; X11) Via 通知中间网关或代理服务器地址，通信协议 Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1) Warning 关于消息实体的警告信息 Warn：Warn: 199 Miscellaneous warning Response部分 header 说明 示例 Accept-Ranges 表明服务器是否支持指定范围请求及哪种类型的分段请求 Accept-Ranges:bytes Age 从原始服务器到代理缓存形成的估算时间（以秒计） Age:12 Allow 对某网络资源的有效请求行为，不允许返回405 Allow:GET,HEAD Cache-Control 告诉所有缓存机制是否可以缓存及哪种类型 Cache-Control:no-cache Content-Encoding Web服务器支持的返回内容压缩编码类型 Content-Encoding-gzip Content-Language 响应体的语言 Content-Language:en,zh Content-Location 请求资源可替代的备用的另一地址 Content-Location:/index.htm Content-MD5 返回资源的MD5校验值 Content-MD5:Q2hlY2sgSW50ZWdyaXR5IQ== Content-Type 返回内容的MIME类型 Content-Type:text/html;charset=utf-8 Date 原始服务器消息发出的时间 Date:Tue,15 Nov 2010 08:12:31 GMT ETag 请求变量的实体标签的当前值 ETag:”737060cd8c284d8af7ad3082f209582d” Expires 响应过期的日期和时间 Expires:Thu, 01 Dec 2010 16:00:00 GMT Last-Modified 请求资源的最后修改时间 Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT location 用来重定向接收方到非请求URL的位置来完成请求或标识新的资源 location: http://example.com Pragma 包括实现特定的指令，它可应用到响应链上的任何接收方 Pragma:no-cache Proxy-Authenticae 它指出认证方案和可应用到代理的该URL上的参数 Proxy-Authenticate:Basic refresh 应用于重定向或一个新的资源被创造，在5秒之后重定向 Refresh:5;url=http://example.com Retry-After 如果实体暂时不可取，通知客户端在指定时间之后再次尝试 Retry-After:120 Server Web服务器软件名称 Server: Apache/1.3.27 (Unix) (Red-Hat/Linux) Set-Cookie 设置Http Cookie Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1 Trailer 指出头域在分块传输编码的尾部存在 Trailer:Max-Forwards Transfer-Encoding 文件传输编码 Transfer-Encoding:chunked Vary 告诉下游代理是使用缓存响应还是原始服务器请求 Vary:* Via 告知代理客户端响应是通过哪里发送的 Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1) Warning 警告实体可能存在的问题 Warning: 199 Miscellaneous warning WWW-Authenticate 表明客户端请求实体应该使用的授权方案 WWW-Authenticate: Basic 6. 前端HTTP运用6.1 JavaScript操纵HTTP的方法 用脚本设置window对象的location属性 调用表单对象的submit()方法 Ajax技术的实现 6.2 Ajax vs CometAjax并不单单指xhr,泛指使用脚本操纵HTTP和Web服务器进行数据交换，不会导致页面重载的技术。 Comet是和使用脚本操纵HTTP的Web应用架构相关的术语。在Comet中，Web服务器发起通信并异步发送消息到客户端。如果客户端要响应服务器发送的消息，则会使用Ajax技术发送或请求数据。 在Ajax中，客户端从服务器端拉数据；在Comet中，服务器向客户端推数据。 6.3 Ajax技术的实现 的src属性 这个元素无法实现完整的Ajax传输协议，因为数据交换是单向的，客户端发送数据到服务器，但服务器的响应一直是张图片导致客户端无法轻易从中提取信息。 的src属性 为了把这个元素作为Ajax的传输协议来使用，脚本首先要把发送给Web服务器的信息编码到URL中，然后设置这个元素的src为URL。服务器能创建一个包含响应内容的HTML文档，并把它返回给Web浏览器，并且在中显示。 此外，还需对用户不可见。 脚本能通过遍历的文档对象来读取服务器端的响应，这种访问受限于同源策略。 &lt;script&gt;的src属性（JSONP） &lt;script&gt;的src属性能设置URL并发起HTTP GET请求。它可以跨域通信而不受限于同源策略。使用基于&lt;script&gt;的Ajax传输协议时，服务器的响应采用JSON编码的数据格式，当执行脚本时，JavaScript解析器能自动将其”解码”。 由于使用JSON数据格式，因此这种Ajax传输协议又叫JSONP。 XMLHttpRequest对象 XMLHttpRequest对象定义了用脚本操纵HTTP的API，包含GET和POST请求的能力，异步使用，能用于HTTP和HTTPS请求，能获取任何类型的文本文档 7. 示例我们来看看如何结合上述学到的HTTP知识和xhr结合，来加深我们对HTTP知识的理解。 实例化 1var request = new XMLHttpRequest(); //IE7+和其他浏览器 HTTP请求（4个部分） HTTP请求方法或”动作” GET：当请求对服务器没有任何副作用以及当服务器的响应是可缓存的。 POST：常用于HTML表单，在请求主体中包含额外的数据，且这些数据常存储到服务器上的数据库中（副作用） HEAD：得到广泛支持 正在请求的URL 如果指定绝对URL，协议、主机和端口通常必须匹配所在的文档对应的内容，跨域的请求通常会报错（2级的XmlHttpRequest规范允许）。 以上的调用open()来设置 12request.open('GET', //开始一个HTTP GET请求 'data.csv'); //URL的内容 可选的请求头集合 调用setRequestHeader()来设置请求头，当对相同的头调用多次的setRequestHeader()，新值不会取代之前指定的值，相反，HTTP请求将包含这个头的多个副本或这个头指定多个值。 此外，XMLHttpRequest将自动添加某些头而防止伪造它们，因此无法自行指定这些头。 ` Accept-Charset Content-Transfer-Encoding TE Accept-Encoding Date Trailer Connection Expect Transfer-Encoding Content-Length Host Upgrade Cookie Keep-Alive User-Agent Cookie2 Referer Via ` 常见的，在POST请求中，需要设置请求主题的MIME类型 1request.setRequestHeader('Content-Type','text/plain'); 可选的请求主体，并向服务器发送请求 12request.send(null);//GET 方法request.send(data); //POST 方法，发送一些表单数据之类的 HTTP响应（3个部分） 一个数字和文字组成的状态码，用来显示请求的成功和失败 status和statusText来获取状态码 一个响应头集合 getResponseHeader()和getAllResponseHeaders()能查询响应头。XmlHttpRequest会自动处理cookie：它会在getAllResponseHeaders()头返回中过滤掉cookie头，而如果给getResponseHeader()传递”Set-Cookie”和”Set-Cookie2”则返回null。 响应主体 从responseText属性中得到响应主体的文本形式。 异步使用 发送请求后，即调用send()，为了响应准备就绪时得到通知，必须监听XMLHttpRequest对象上的readystatechange事件。为了理解这个事件类型，必须了解一下readyState属性。 readyState是一个整数，指定了HTTP请求的状态。 常量（旧版本IE不支持） 值 含义 UNSET 0 open()尚未调用 OPENED 1 open()已调用 HEADERS_RECEIVED 2 接收到头信息 LOADING 3 接收到响应体 DONE 4 响应完成 1234567891011121314//发出一个HTTP GET请求以获得指定URL的内容的完整例子function getText(url,callback)&#123; var request = new XMLHttpRequest(); request.open('GET',url); request.onreadystatechange = function()&#123; if (request.readyState === 4 &amp;&amp; request.status === 200)&#123; var type = request.getResponseType('Content-Type'); if(type.match(/^text/))&#123; callback(request.responseText); &#125; &#125; &#125; request.send(null);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[样式优先级]]></title>
      <url>%2F2016%2F11%2F30%2Fcascade%2F</url>
      <content type="text"><![CDATA[样式是具有权重的，或者说优先级，这是为了解决当多个样式同时作用于同一个dom元素时的冲突问题。 那么样式的优先级是如何计算的？ 1. 概述层叠（cascade）：是指当一个DOM元素对应的多个样式存在冲突时，浏览器解决冲突的一些规则。它由四个概念组成 特殊性 重要性 来源 顺序 2. 特殊性特殊性是解决多样式冲突的一个重要的概念，在css中，所有样式声明都有自己选择器，而不同的选择器具有不同的特殊性 根据选择器的不同，一共有5个权重 内联样式：1000 ID选择器：100 类选择器（包括属性选择和伪类）：10 元素和伪元素选择器：1 结合符和通配符：0 注意：0特殊性的，相比完全没有特殊性的继承样式，优先级更高 12* &#123; color:red;&#125;h1 &#123;coloe:black;&#125; 1&lt;h1&gt;什么&lt;em&gt;颜色&lt;/em&gt;&lt;/h1&gt; 3. 重要性可以通过!important来标志出重要声明，事实上，!important不具备任何特殊性。浏览器会将标识为重要的声明放到一起，相比普通组，重要组中的声明总会胜出。 12body h1 &#123;color:red;&#125; /*特殊性权重 = 2*/h1 &#123;color:orange !important;&#125;/*特殊性权重 = 1*/ 由于第二条规则中有!important标志，所以尽管特殊性只有1，仍然胜出。 如果重要组中的声明发送了冲突，就还是要采用计算特殊性的方式来解决 12h1#title &#123;color:red !important;&#125;/*特殊性权重 = 101*/h1.title &#123;color:orange !important;&#125;/*特殊性权重=11*/ 则第一条规则会胜出。 4. 来源由于有些浏览器或者浏览器插件允许用户自己定义样式（称之读者声明），由此就存在开发者创建的声明与用户自定义之间的孰轻孰重的问题。 优先级从高到低： 读者的重要声明 开发者的重要声明 开发者的正常声明 读者的正常声明 用户代理的声明（浏览器默认样式） 5. 顺序在综合考虑了前面的所有因素之后，最后的解决冲突的办法就是声明顺序。 一句话：越后声明的优先级越高 12h1&#123;color:blue;&#125;h1&#123;color:red;&#125; 第二条会胜出 12345&lt;style&gt; .a &#123;color:blue;&#125; .b &#123;color:red;&#125;&lt;/style&gt;&lt;p class="b a"&gt;123&lt;/p&gt; 文字的颜色是：red，注意顺序是值声明顺序，而不是使用顺序。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[常见head标签总结]]></title>
      <url>%2F2016%2F11%2F30%2Fhead%2F</url>
      <content type="text"><![CDATA[以下总结了一些常用的head标签以及他们的作用。 字符集1&lt;meta charset="utf-8"&gt; 语言简体中文 1&lt;html lang="zh-cmn-Hans"&gt;&lt;/html&gt; 繁体中文 1&lt;html lang="zh-cmn-Hant"&gt;&lt;/html&gt; 版本内核选择优先使用IE最新版本和Chrome 1&lt;meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"/&gt; 360使用Google Chrome Frame，即极核速 12&lt;meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"/&gt;&lt;meta name="renderer" content="webkit"&gt; SEO优化title是SEO最重要的部分，尽量突出关键字 1&lt;title&gt;title&lt;/title&gt; 关键词 1&lt;meta name="keywords" content="your keywords"&gt; 页面描述内容 1&lt;meta name="discription" content="your description"&gt; 网页作者 1&lt;meta name="author" content="author,email,address"&gt; robots协议 定义网页搜索引擎的索引方式 取值：no,noindex,nofollow,all,index,follow 1&lt;meta name="robots" content="index,follow"&gt; viewport 让布局在移动浏览器上显示得更好，是移动端开发的重要的头标签。 content参数： | 类型 | 作用 | 取值 | | :— | :— | :— | | width | viewport宽度 | 数值/device-width | | height | viewport高度 | 数值/device-height | | initial-scale | 初始缩放比例 | 数值：1 | | maximum-scale | 最大缩放比例 | 数值 | | minimum-scale | 最小缩放比例 | 数值 | | user-scalable | 是否允许用户缩放 | yes/no | 常见设置 1&lt;meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"&gt; 设置 minimal-ui，IOS 7新增属性，可以在页面加载时最小化上下状态栏 1&lt;meta name="viewport" content="width=device-width,user-scalable=no,minimal-ui"&gt; 适配 iphone6 和 iphone6 plus 大部分4.7~5寸的安卓设备的viewport宽为360px，iphone6 上却是375px 大部分5.5寸的安卓设备的viewport宽为400px，iphone6 plus却是414px 12&lt;meta name="viewport" content="width=375"&gt;&lt;meta name="viewport" content="width=414"&gt; 百度禁止转码1&lt;meta http-equiv="Cache-Control" content="no-siteapp"&gt; IOS设备添加到主屏后的标题（IOS6 新增） 1&lt;meta name="apple-mobile-web-app-title" content="标题"&gt; 是否启用WebApp全屏模式 1&lt;meta name="apple-mobile-web-app-capable" content="yes"&gt; 设置状态栏的背景颜色，需启用WebApp的全屏模式 content参数 default：默认 black：黑色 black-translucent：黑色半透明 1&lt;meta name="apple-mobile-web-app-status-bar-style" content="black"&gt; 禁止数字自动识别为电话号码 1&lt;meta name="format-detection" content="telephone=no"/&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于undefined的小知识]]></title>
      <url>%2F2016%2F11%2F30%2Fundefined%2F</url>
      <content type="text"><![CDATA[在一些比较有年代的代码中，我们时常会看到 1;!function(win, undefined)&#123;&#125; 这里为什么还有一个参数是undefined? undefined在Ecmascript 3中，undefined是可变的，不是关键字，这意味着它的值可以被覆盖或者重新赋值。如undefined = true。 在ECMASCRIPT 5严格模式（’use strict’;）中解析器将抛出一个类型错误。现在的代码基本不用考虑这个问题了 因此我们需要保护我们的undefined,像下面这样： 123;!function(win,undefined)&#123; //函数作用域&#125; 这意味着，如果有人重新定义了undefined，就无法对我们的代码产生什么影响了 12345//对undefined进行了赋值undefined = true;;!function(win,undefined)&#123; //undefined是一个局部变量&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据类型检测]]></title>
      <url>%2F2016%2F11%2F30%2Fis-type%2F</url>
      <content type="text"><![CDATA[在js中提供两种检测类型的方法，但是它们并不总是靠谱。 typeof instanceof 下面我们来看看各个类型的应该如何进行检测比较靠谱 1. 基本类型基本类型(除null之外)的检测使用typeof，它的语法很简单 123456789var number = 1, string = "s", boolean = true, un = undefined,typeof number; // "number"typeof string; // "string"typeof boolean;// "boolean"typeof un; // "undefined" 1.2 null如果我们使用typeof来检测，结果会是 12var n = null;typeof n;//"object" 有人说这是个bug，有人说这是因为null本身就代表着一个空对象，我们也经常用null来解除引用。不管怎么说，我们可以这样检测null 12345678var n = null;function isNull(n)&#123; if(!n &amp;&amp; typeof n !== "undefined")&#123; return true; &#125; return false;&#125;isNull(n);// true 1.3 非数字判断一个变量是否是数字，可以使用isNaN()，这个方法的意思是is not a numher，也就是说返回true的时候说明变量不是一个数字。 123456var a = 1, b = "s", c = "1";isNaN(a); // falseisNaN(b); // trueisNaN(c); // true 2. 引用类型引用类型使用typeof检测，返回都是”object”。这其实没什么意义，我们要知道的是变量具体是哪个引用类型的，例如数组，自定义的类型等等。这个时候可以用instanceof，它的语法是 实例 instanceof 对象构造函数 12345var arr = [];arr instanceof Array; // truefunction Person()&#123;&#125;;var p = new Person();p instanceof Person; // true instanceof不仅能检测构造对象的构造器，还检测原型链。 123var now = new Date();now instanceof Date; // truenow instanceof Object; // true 2.1 数组检测数组在编程中相当常见，在框架中也是，如何准确地检测数组类型，是相当重要的。 可能有人会说了，使用instanceof不就可以了。非也。在js中，有一个很古老的跨域问题：在iframe之间来回传递数组，而instanceof不能跨帧。 什么叫不能跨帧？假设在一个浏览器的帧（frame A）里的一个对象传入到另外一个帧（frame B）中，两个帧都定义了一个构造函数Person，如果来自帧A的对象是帧APerson的实例，则 frameAPersonInstance instanceof frameAPerson; //true frameAPersonInstance instanceof frameBPerson; //false 那怎么办？ 首先，有人提出了使用duck typing的思路来解决这个问题，duck typing的意思就是：像鸭子一样走路、游泳并且嘎嘎叫的就是鸭子，这是个很有意思的想法，它的本质就是我们关注对象能做什么，不是关注对象是什么，采用这样的思路，我们检测对象实例是否有sort属性来判断对象实例是否是一个数组，具体实现如下 123function isArray(value) &#123; return typeof value.sort === "function";&#125; 之后，kangax发现了一个很有趣的现象，调用某个值的内置toString()方法在所有浏览器中都返回标准的字符串结果，对于数组来说，返回的字符串为”[object Array]”，这个方法对识别内置对象都非常有效，因此jq也是采取了这种方式来实现的isArray()的方法。 123function isArray(value) &#123; return Object.prototype.toString.call(value) === "[object Array]";&#125; 之后，ECMA5将Array.isArray()正式引入JavaScript，提供了一个能准确检测一个变量是否为数组类型的 1Array.isArray(variable); 3. 最后到这里，你以为已经解决了所有的类型检测问题了吗？并不是。在《JavaScript框架设计》这本书中，详细地谈论各种类型检测的兼容性问题，并且在massframework给出了一个很不错的实现，从代码里面来学习可以学到更多。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 建立类型的映射var class2type = &#123; "[objectHTMLDocument]" : "Document", "[objectHTMLCollection]" : "NodeList", "[objectStaticNodeList]" : "NodeList", "[objectIXMLDOMNodeList]" : "NodeList", "[objectDOMWindow]" : "Window", "[object global]" : "Window", //safari 4.04 "null" : "null", "NaN" : "NaN", "undefined" : "undefined"&#125;;// 正常情况下的类型"Boolean,Number,String,Function,Array,Date,RegExp,Window,Document,Arguments,NodeList" .replace(/[^, ]/g, function(name) &#123; class2type['[object ' + name + ']'] = name; &#125;);var toString = class2type.toString;mass.type = function(obj,str)&#123; var result = class2type[ (obj == null || obj !== obj) ? obj : toString.call(obj) ] || obj.nodeName || '#'; if(result.charAt(0) === '#' )&#123; //兼容旧版浏览器与处理个别情况，如window.opera //hack,利用IE6,IE7,IE8 window == document 为 true，document == window 为 false的特性 if(obj == obj.document &amp;&amp; obj.document != obj)&#123; result = 'Window'; &#125; else if (obj.nodeType === 9)&#123; //nodeType 属性返回以数字值返回指定节点的节点类型。9代表document result = 'Document'; &#125; else if (obj.callee)&#123; //arguments 特有的属性 resutl = 'Arguments'; &#125; else if (isFinite(obj.length) &amp;&amp; obj.item)&#123; //obj.item()方法，可返回节点列表中处于指定的索引号的节点。 result = 'NodeList'; &#125; else &#123; result = toString.call(obj).slice(8,-1); //[object XXXX] &#125; &#125; //提供一个进行类型比较的功能 if(str)&#123; return str === result; &#125; return result;&#125; 4. 参考 《编写可维护的JavaScript》 《JavaScript框架设计》]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据类型转换]]></title>
      <url>%2F2016%2F11%2F30%2Fdata-type-transform%2F</url>
      <content type="text"><![CDATA[在javascript中，数据类型转换是很常见的，尤其是隐式的数据类型转换。 1. 字符串转为数字1.1 显示转换 Number() parseInt() parseFloat() 12Number('100x'); //NaNparseInt('100x'); //100 Number()中的字符串必须是都是数字，而parseInt和parseFloat则会解析字符串，尽可能转为数字 1.2 隐式转换12'100'-1 //99+ '100' //100,+号作为单目运算，是正号运算 注意 12'100' + 1 // 10011 + '100' // 1001 1.3 特殊转换 无法被转换为数值的字符串 =&gt; NaN 空字符串 =&gt; 0 2. 数字转为字符串2.1 显式12String(1); // '1'1.toString();//'1' 2.2 隐式12foo + '100' //foo100100 + 'foo' //100foo 2.3 特殊数值 数值NaN =&gt; ‘NaN’ 数值Infinity =&gt; ‘Infinity’ 数值-Infinity =&gt; ‘-Infinity’ 3. 转为boolean3.1 为false的情况 0 NaN null undefined ‘ ‘(空字符串) 3.2 !!进行转换12!!'foo' // true!!0 //false 4. 从Object类型转换为基本数据类型4.1 Object转为数字一般情况下，Object类型是无法直接转为数字的。 123var obj = &#123;&#125;;obj++;obj; //NaN 对象要有能返回恰当数值的valueOf方法，则可以 123456var obj = &#123;&#125;;obj.valueOf = function() &#123; return 1;&#125;obj++;obj; //2 4.2 Object转为字符串可以通过改写Object.toString()来实现自己想要的类型转换 4.3 数组类型转为基本数据类型 [] =&gt; ‘’(空字符串) 0 false [9] =&gt; 9 ‘9’ true 5. 数字取整~是一个按位取非的操作，返回数值的反码，是二进制操作，JavaScript中的number都是double类型的，在位操作的时候会转化为int，两次就还是原来的数 12~~3.1415 // 3 等同于parseInt()~~5.678 //5]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数组去重]]></title>
      <url>%2F2016%2F11%2F29%2Fjs-unique%2F</url>
      <content type="text"><![CDATA[3种方式实现数组去重。 方式1：使用shift()获取并删除删除数组的第一个元素，判断这个元素是否还存在于数组中，如果存在则说明这个元素的是重复的；如果不存在，进行push()操作 123456789101112function unique(a)&#123; if(Array.isArray(a))&#123; var len = a.length,item; while(len--)&#123; item = a.shift(); if(a.indexOf(item) === -1)&#123; a.push(item); &#125; &#125; &#125; return a;&#125; 方式2：建立一个哈希表，通过对象属性查询去除重复元素 123456789101112131415function unique(array)&#123; var hash = &#123;&#125;, len = array.length, result = [], i; for(i = 0; i &lt; len; i++)&#123; if(!hash[a[i]])&#123; hash[a[i]] = true; result.push(a[i]); &#125; &#125; return result;&#125; 方式3：思路和方式2类似，但是简洁很多 1234567function unique(arr) &#123; var hash = &#123;&#125;; return arr.filter(function (n) &#123; hash[n] = (hash[n] || 0); return (++hash[n] &lt;= 1); &#125;);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数组反转]]></title>
      <url>%2F2016%2F11%2F29%2Fjs-reverse%2F</url>
      <content type="text"><![CDATA[两种方式实现数组反转。 使用栈，后进后出 12345678function reverse(array)&#123; var stack = [],item; while((item = array.pop()))&#123; stack.push(item); &#125; array = stack; return array;&#125; 利用头尾下标交换 12345678910111213function reverse(arr)&#123; var i = 0, j = arr.length-1, tmp; while(i &lt; j)&#123; tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; i++; j--; &#125; return arr;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数组合并]]></title>
      <url>%2F2016%2F11%2F29%2Fjs-merge%2F</url>
      <content type="text"><![CDATA[合并两个有序数组 12345678910111213141516function merge(arr1,arr2)&#123; var i = 0,j = 0, len1 = arr1.length, len2 = arr2.length, tmp = []; while(i &lt; len1 &amp;&amp; j &lt; len2)&#123; if(arr1[i] &lt; arr2[j])&#123; tmp.push(arr1[i++]); &#125; else &#123; tmp.push(arr2[j++]); &#125; &#125; while(i &lt; len1)tmp.push(arr1[i++]); while(j &lt; len2)tmp.push(arr2[j++]); return tmp;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[this使用技巧]]></title>
      <url>%2F2016%2F11%2F29%2Fthis%2F</url>
      <content type="text"><![CDATA[掌握js中的this是学好js的关键。在JS中，我们把this关键字当成一个快捷方式，或者说是引用（reference）。this关键字指向的是当前上下文（context）的主体（subject），或者当前正在被执行的代码块的主体。 下面通过几个例子来看看深入理解this。 1. 概述this关键字始终指向一个对象并持有这个对象的值，尽管它可以出现在全局范围（global scope）以外的地方，但它通常出现在方法体中。如果使用严格模式（strict mode），并在全局方法（global functions）或者没有绑定到任何对象的匿名方法中使用this关键字时，this将会指向undefined。 1234"use strict";(function()&#123; console.log(this); //undefined&#125;)(); 2. this的核心如果一个方法内部使用了this关键字，当且仅当对象调用方法时this关键字才会被赋值，而且，当方法被调用时，this的赋值又严格依赖于实际调用这个方法的对象，也就是说，this通常会被赋予调用对象的值。 也有一些特殊的情况，在下面将会讲到 3. 全局范围内的this在全局域中，代码在浏览器执行，所有变量和方法都属于window对象，因此在全局域中使用this关键字的时候，它会被指向全局变量window对象。 1234567891011121314151617181920var firstName = 'Peter', lastName = 'Ally';function showFullName()&#123; console.log(this.firstName + ' ' + this.lastName);&#125;var person = &#123; firstName : 'foo', lastName : 'bar', showFullName : function()&#123; console.log(this.firstName + ' ' + this.lastName); &#125;&#125;showFullName(); //Peter Allywindow.showFullName(); //Peter Allyperson.showFullName(); //foo bar 4. call/apply与this通过使用不同的对象来对方法进行调用，当前的上下文对象同样可以被切换。这里就要借助两个函数call和apply。 12345678910111213141516var person = &#123; firstName : 'foo', lastName : 'bar', showFullName : function()&#123; console.log(this.firstName + ' ' + this.lastName); &#125;&#125;;var anotherPerson = &#123; firstName : 'Peter', lastName : 'Ally'&#125;;person.showFullName();//foo barperson.showFullName.call(anotherPerson); //Peter Ally 5. 作用域绑定12345678var user = &#123; name : 'zhang', clickHandler : function()&#123; console.log(this.name); &#125;&#125;button.onclick = user.clickHandler; //undefined，无法读取对象的name属性 分析：当把user.clickHandler当作回调函数传入button元素的click事件，user.clickHandler中的this将不再执行user。因为真正调用user.clickHandler的对象是button对象。 当上下文改变时，当我们在其它对象而非原对象上执行某个方法的时候，显然this关键字不再指向定义了this关键字的原对象。 解决方法：使用bind，apply，call来强制保证作用域，即this指向的对象。 bind 1button.onclick = user.clickHandler.bind(user); apply/call 123button.onclick = function()&#123; user.clickHandler.call(user);&#125; 来看两个完整示例，加深理解。 123456789101112131415161718var name = 'global';var user = &#123; name : 'user', showName : function()&#123; console.log(this.name); &#125;&#125;//把方法赋值给变量var showName1 = user.showName;showName1(); //global//使用bind绑定作用域var showName2 = user.showName.bind(user);showName2();//user 123456789101112131415161718192021222324252627282930313233/* 下面代码中有两个对象。其中一个定义了avg方法，另一个不包含avg的定义。 我们用另一个对象来借用前一对象的avg方法。*/var gameController = &#123; scores: [20, 34, 55, 46, 77], avgScore: null, players: [&#123; name: "Tommy", playerID: 987, age: 23 &#125;, &#123; name: "Pau", playerID: 87, age: 33 &#125;]&#125;var appController = &#123; scores: [900, 845, 809, 950], avgScore: null, avg: function() &#123; var sumOfScores = this.scores.reduce(function(prev, cur, index, array) &#123; return prev + cur; &#125;); this.avgScore = sumOfScores / this.scores.length; &#125;&#125;//原文中的第二参数是多余的，写上会造成理解的误差appController.avg.apply(gameController);console.log(gameController.avgScore); 6. 闭包与this内部方法不能直接使用this关键字来访问外部方法的this变量，因为this变量只能被特定的方法本身使用。 12345678910111213141516171819var user = &#123; tournament: "The Masters", data: [&#123; name: "T. Woods", age: 37 &#125;, &#123; name: "P. Mickelson", age: 43 &#125;], clickHandler: function() &#123; this.data.forEach(function(person) &#123; console.log("What is This referring to? " + this); console.log(person.name + " is playing at " + this.tournament); &#125;) &#125;&#125;user.clickHandler(); // What is "this" referring to? [object Window] 为了保证闭包中的this的指向的正确， 123456789101112131415161718192021var user = &#123; tournament: "The Masters", data: [&#123; name: "T. Woods", age: 37 &#125;, &#123; name: "P. Mickelson", age: 43 &#125;], clickHandler: function() &#123; //保存this对象 var that = this; this.data.forEach(function(person) &#123; console.log("What is This referring to? " + that); console.log(person.name + " is playing at " + that.tournament); &#125;) &#125;&#125;user.clickHandler(); // What is "this" referring to? [user] 7. 来源原文]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[协程]]></title>
      <url>%2F2016%2F11%2F29%2Fcoroutine%2F</url>
      <content type="text"><![CDATA[要理解es6中的generator，就必须了解一个概念协程。 1. 基本概念协程，又成为微线程（coroutine）。 进程(process) vs 线程(thread) 我们都知道在操作系统级别上有两个重要的概念(也是实体):进程(process)和线程(thread)，这两个东西是用于操作系统模拟并行的，在单个CPU上，os通过调度算法，让CPU轮流执行线程或者进程，来达到程序的并发执行。 那么协程又是什么？首先要明确的是，协程是编译器级别的，而并非线程和进程一样是操作系统级别的。协程的实现，通过是对某个语言做相应的提议，然后通过后成编译器标准，然后编译厂商来实现该机制。 2. 作用协程的作用是什么？ 简单来说，就是实现函数的分段式执行。就是一个函数的执行可以主动放弃CPU的控制权，先挂起，让其他的函数先执行，然后在返回，从上次执行结束的地方继续执行。 这样看起来很像是多线程轮流执行。但是却有着很大的区别：协程是一个线程执行。 因为是一个线程执行，所以不存在线程的切换，而是由程序自身控制，也就不存在所谓的线程切换的开销。 不需要多线程的锁机制。因为只有一个线程，也就不存在同时写变量的冲突。在协程中控制共享资源不加锁，只需要判断状态就好了。这也说明协程的执行效率很高一些。 举个生产者消费者模型基于抢占式多线程编程的实现（伪代码） 1234567891011121314151617// 资源，队列容器var q = [];// 消费者进程loop(); // 循环等待lock(q); // 加锁var item = getResourceFrom(q); // 获取资源unlock(q); // 操作结束，资源解锁operatingResource(item);sleep;// 生成者线程loop(); // 循环等待var item = createResource(p); // 生产资源lock(q); // 加锁q.push(item); // 写入资源unlock(q); // 解锁 可以看到，以上的代码中有两个特点 对资源操作需要进行加锁和解锁的操作。（保证线程安全） 消费者线程必须通过sleep，让出CPU，用于执行生产者线程使用。 那么如果是协程的编程模式，就简单地多。 1234567891011121314151617181920212223242526272829303132var q = [];var count = 0;// 消费者function *consumer() &#123; while (true)&#123; var item = yield producer(); console.log(item); &#125;&#125;// 生产者function producer() &#123; q.push(count++);&#125;function main () &#123; const consumerGen = consumer(); // 我们可以通过代码来控制其交替执行 // 执行到获取item之前，放弃执行权，先执行producer(), consumerGen.next(); // 之后可以获取item，然后再放弃执行权，执行producer，一直循环 consumerGen.next(q.shift()); consumerGen.next(q.shift()); consumerGen.next(q.shift()); consumerGen.next(q.shift()); consumerGen.next(q.shift()); consumerGen.next(q.shift());&#125;main(); 执行效果如下： TBD…)- 3. 参考 协程-廖雪峰 C++ 协程与网络编程 谈谈协程和C语言的协程 协程（Coroutine）并不是真正的多线程 协程（一）原理]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[理解原型链]]></title>
      <url>%2F2016%2F11%2F29%2Fprototype%2F</url>
      <content type="text"><![CDATA[本文将围绕原型链机制，讲解几个重要的概念。 1. 概述概念 原型链是一种机制，指的是JavaScript每个对象包括原型对象都有一个内置的[[proto]]属性指向创建它的函数对象的原型对象，即prototype属性。 作用 原型链的存在，只要是为了实现对象属性的继承。 1.1 函数对象在JavaScript中，函数即对象。 1.2 原型对象当定义一个函数对象的时候，会包含一个预定义的属性，叫prototype，这就属性称之为原型对象。 123//函数对象function F()&#123;&#125;;console.log(F.prototype) 123//普通对象var a = &#123;&#125;;console.log(a.prototype);//undefined 1.3 __proto__JavaScript在创建对象的时候，都会有一个[[proto]]的内置属性，用于指向创建它的函数对象的prototype。原型对象也有[[proto]]属性。因此在不断的指向中，形成了原型链。 1234//函数对象function F()&#123;&#125;;var f = new F();console.log(f.__proto__) 123//普通对象var a = &#123;&#125;;console.log(a.__proto__);//undefined 1.4 new当使用new去调用构造函数时，相当于执行了 123var o = &#123;&#125;;o.__proto__ = F.prototype;F.call(o); 因此，在原型链的实现上，new起到了很关键的作用。 1.5 constructor原型对象prototype上都有个预定义的constructor属性，用来引用它的函数对象。这是一种循环引用。 12function F()&#123;&#125;;F.prototype.constructor === F; 在实际运用中，经常会有下列的写法 12345function F()&#123;&#125;;F.prototype = &#123; constructor : F, doSomething : function()&#123;&#125;&#125; 这里要加constructor是因为重写了原型对象，constructor属性就消失了，需要自己手动补上。 2. 原型链的内存结构12345function F()&#123; this.name = 'zhang';&#125;;var f1 = new F();var f2 = new F(); 为了严谨起见，区分对象和变量]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ubuntu搭建java环境]]></title>
      <url>%2F2016%2F11%2F29%2Fubuntu-java%2F</url>
      <content type="text"><![CDATA[环境： ubuntu 14.01 英文系统操作： 搭建java环境 1. 下载解压下载jdk（tar.gz） 解压 1tar -xvf jdkxx.tar.gz 2. 配置环境变量配置环境变量，有两种方式 系统全局环境变量，放置在/etc/profie(不建议) 用户环境变量，放置在~/.bashrc中 打开配置文件 1gedit ~/.bashrc 在文件后面添加 12345# set java environmentexport JAVA_HOME=/home/zhang/software/jdk1.8.0export JRE_HOME=$JAVA_HOME/jreexport CLASSPATH=$JAVA_HOME/lib:$CLASSPATHexport PATH=$JAVA_HOME/bin:$PATH 配置文件生效 1source ~/.bashrc 3. 验证在终端输入 1java -version]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ubuntu安装截图软件shutter]]></title>
      <url>%2F2016%2F11%2F29%2Fubuntu-shutter%2F</url>
      <content type="text"><![CDATA[环境： ubuntu 14.01 英文系统操作： 安装截图软件shutter，并且设置截图的快捷键 1. 添加软件源并安装如果没有添加，安装的shutter不是截图工具 123sudo add-apt-repository ppa:shutter/ppasudo apt-get updatesudo apt-get install shutter 安装成功后，在bash中搜索shutter 2. 设置快捷键 打开系统设置 打开keyboard键盘设置 添加成功之后，设置快捷键 单击右侧Disabled，然后快速按下ctrl+alt+a 3. 使用 按下快捷键ctrl+alt+a，然后选择要截图的区域，之后双击，就会出现 这个时候已经截图成功了，我们可以进行进一步的编辑，点击edit,即可编辑]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ubuntu安装微软雅黑字体]]></title>
      <url>%2F2016%2F11%2F29%2Fubuntu-font%2F</url>
      <content type="text"><![CDATA[环境： ubuntu 14.01 英文系统操作： 安装微软雅黑字体 具体步骤首先在window下的c://window/Fonts 中找出msyh.ttc和msya.ttf(最好是将所有关于msyh的)，将其拷贝出来 切换到ubuntu下，我们可以在/usr/share/fonts下创建一个文件夹，用于放置这个字体文件 12cd /usr/share/fontssudo mkdire winfonts 之后将该字体文件拷贝到winfonts中，改变字体文件的访问权限，在winfonts文件夹下执行 1sudo chmod 744 * 然后根据字体文件生成核心字体信息 123sudo mkfontscalesudo mkfontdirsudo fc-cache -fv 之后注销一下即可。 接下来，就是要使用我们导入的微软字体，可以在软件中心搜索unity tweak tool，然后安装 之后打开软件，就可以进入font选项 然后就可以设置]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ubuntu安装中文输入法]]></title>
      <url>%2F2016%2F11%2F29%2Fubuntu-input%2F</url>
      <content type="text"><![CDATA[环境： ubuntu 14.01 英文系统操作： 安装fcitx和中文输入法 1. 安装fcitx打开软件下载中心，搜索fcitx，安装fcitx 2. 切换输入 打开bash，输入input，打开input method 一直进行下一步，直到 然后点击直到结束，之后重启电脑，就可以看到 2. 安装搜狗拼音下载搜狗拼音的linux 下载之后点击安装既可，之后就可以看到搜狗输入法 3. 安装googlepinyin搜狗输入法有时候会有点问题，个人还是喜欢googlepinyin 安装了fcitx之后，再安装googlepinyin 1sudo apt-get install fcitx-googlepinyin 之后可以在有上方的输入法中点击配置，新添我们安装的谷歌输入法]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[高级定时器]]></title>
      <url>%2F2016%2F11%2F29%2Ftimer%2F</url>
      <content type="text"><![CDATA[1. 基础知识1.1 理解定时器要理解setTimeout()和setInterval()，必须结合事件循环机制，简单来说，这两个指定的时间只是触发定时器事件的时间，然后回调函数会被放到任务队列中，等待主执行栈的任务执行完成之后，才会调用回调函数。 1.2 重复的定时器setInterval有两个问题： 某些间隔会被跳过 多个定时器的代码执行之间的间隔可能会比预期的小 为了避免setInterval()的重复定时器的2个缺点，可以使用链式的setTimeout()调用 123456setTimout(function()&#123; //处理中 setTimeout(arguments.callee,interval);&#125;,interval); 这种写法可以保证在下一次定时器代码执行之前，至少要等到指定的间隔，避免了连续的运行。 1.3 创建异步任务定级器一个高级的运用就是将一个同步的代码变成异步的。在很多时候我们在初始化页面时，为了加快页面的展示，就必须避免一些繁重的任务阻塞到UI线程，因此可以利用定时器来创建一个异步执行的代码。 12345function lookup()&#123; // 查询任务，可能会阻塞UI线程&#125;var timer;timer &amp;&amp; (timer = setTimeout(lookup, 0)); 2. 进阶知识此外，定时器还有几点特别需要注意的 定时器存在一个最小的时间间隔，最小的间隔大概在4ms左右，在旧版本的IE中，时间间隔会比较长（15.6ms左右）。 间隔的时间也很容易受到外部因素影响，比如电池快没电，或者同时打开的应用程序太多了。 2.1 改造setTimeout如果嫌旧版本IE的最短时钟间隔太大，可以利用image死链时立即执行onerror回调的情况下进行改造 123456789101112var orig_setTimeout = window.setTimeout;window.setTimeout = function (fun, wait)&#123; if(wait &gt; 15)&#123; orig_setTimeout(fun, wait); &#125; else &#123; var img = new Image(); img.onload = img.onerror = function()&#123; fun(); &#125; img.src = "data:,error"; &#125;&#125; 2.2 异步编程浏览器环境与后端nodejs存在各种消耗巨大或阻塞线程的行为，对于JavaScript这样单线程的东西唯一解耦的方法就是提供异步API。 TBD). 3. 参考 《JavaScript高级程序设计》 《JavaScript框架设计》]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[惰性载入函数]]></title>
      <url>%2F2016%2F11%2F29%2Flazy-function%2F</url>
      <content type="text"><![CDATA[1. 概念惰性载入表示函数执行的分支只会在函数第一次调用的时候执行，在第一次调用过程中，该函数会被覆盖为另一个按照合适方式执行的函数，这样任何对原函数的调用就不用再经过执行的分支。 2. 应用场景 &amp; 示例实现事件注册函数，由于各浏览器之间的差异，不得不在用的时候做能力检测，单从功能上讲，已经做到了兼容浏览器，但美中不足的是，每次绑定监听，都会再进行一次检测，这在真实的环境中，显然是多余的，同一个应用环境中，其实只需要检测一次即可。 编写跨平台的ajax模块 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126(function ()&#123; var ajax = &#123; _createXhr : function () &#123; var xhr,curVersion; if(window.XMLHttpRequest)&#123; _createXhr = function () &#123; return new XMLHttpRequest(); &#125; xhr = new XMLHttpRequest(); &#125; else if (window.ActiveXObject) &#123; var versions = [ "MSXML2.XMLHTTP", "MSXML2.XMLHTTP.6.0","MSXML2.XMLHTTP.3.0"]; for (var i = 0; i &lt; versions.length; i++) try &#123; xhr = new ActiveXObject(version[i]) if(xhr)&#123; curVersion = version[i]; _createXhr = function () &#123; return new ActiveXObject(curVersion); &#125; break; &#125; &#125;catch (e) &#123;&#125;; &#125; if(!xhr) &#123; throw new Error("fail to create XHR"); &#125; return xhr; &#125;, _serialize : function(data) &#123; if(typeof data == "object") &#123; var p = []; for(var key in data)&#123; p.push(encodeURIComponent(key) + "=" + encodeURIComponent(data[key])); &#125; return p.join("&amp;"); &#125; else if (typeof data == "string")&#123; return data; &#125; else &#123; throw new Error("fail to serialize parameters"); &#125; &#125;, _get : function(params,xhr) &#123; // get请求 var url = params.url; if(params.data) &#123; url = url.indexOf("?") &gt; 0 ? url : (url + "?"); url += this._serialize(params.data); &#125; xhr.open("get",url); xhr.send(null); &#125;, _post : function(params,xhr) &#123;// post请求 var url = params.url; if(params.data) &#123; var data = this._serialize(params.data); &#125; xhr.open("post",url); // 增加请求头 xhr.setRequestHeader("Content-Type", params.contentType || "application/x-www-form-urlencoded"); xhr.send(data); &#125;, send : function (params)&#123; if (!params.url) &#123; throw new Error("invalid parameters"); &#125; var requestType = params.requestType || "GET"; var timeout = params.timeout || 60000; var callback = params.callback || function()&#123;&#125;; var xhr = ajax._createXhr(); // 超时错误，可以使用timeout和ontimeout， // 这里使用定时器来实现 if("timeout" in xhr)&#123; xhr.timeout = timeout; xhr.ontimeout = function () &#123; callback(&#123;msg:"timeout"&#125;); &#125; &#125; else &#123; var timer = setTimeout(function () &#123; xhr.abort(); callback(&#123;msg:"timeout"&#125;); &#125;,timeout) &#125; // 正常返回 xhr.onreadystateChange = function () &#123; if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123; timer &amp;&amp; clearTimeout(timer); var ret = xhr.responseText; try &#123; ret = typeof JSON.parse == "function"? JSON.parse(ret) : ret; &#125;catch(_)&#123;&#125;; callback(ret); &#125; &#125; // 请求错误 xhr.onerror = function () &#123; timer &amp;&amp; clearTimeout(timer); callback(&#123;msg:"error"&#125;); &#125; // 开启跨域 if("withCredential" in xhr)&#123; xhr.withCredentials = true; &#125; // 处理参数 requestType = requestType.toUpperCase(); switch(requestType)&#123; // 之后可以补充多个请求方法 case "GET" : ajax._get(params, xhr); break; case "POST" : ajax._post(params, xhr); break; &#125; &#125; &#125;; window.ajax = ajax;&#125;)(); 3. 注意点 应用越频繁，越能体现这种模式的优势所在 固定不变，一次判定，在固定的应用环境中不会改变 复杂的分支判断，没有差异性，不需要应用这种模式 4. 参考 《JavaScript高级程序设计》]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[函数节流]]></title>
      <url>%2F2016%2F11%2F29%2Fthrottle%2F</url>
      <content type="text"><![CDATA[1. 基本认识函数节流技术的主要思路是：通过一个定时器，阻断连续重复的函数调用。 2. 应用场景函数节流技术对于用户界面调用的函数，有着一定的意义，特别事件回调函数具备一下特点： 短时间内连续多次触发 大量的DOM操作。 就很适合使用函数节流的技巧来提供我们代码的性能。 3. 例子例如，一个简单的window.resize 12345var count = 0;window.onresize = function()&#123; count++; console.log(count);&#125; 简单的缩放一次就会打印多次。这并不是我们想要的效果。 3.1 解决方案1123456function throttleFunc(method,context)&#123; clearTimeout(method.tId); method.tId = setTimeout(function()&#123; method.call(context); &#125;,100);&#125; demo 12345678var count = 0;function myFunc()&#123; count++; console.log(count);&#125;window.onresize = function()&#123; throttleFunc(myFunc)&#125; 3.2 解决方案2采用闭包的形式 123456789101112function throttle(fn,delay)&#123; var timer = null; return function()&#123; var context = this, args = arguments; clearTimeout(timer); timer = setTimeout(function()&#123; fn.apply(context,arguments); &#125;,delay); &#125;&#125;; demo 1234567var count = 0;function myFunc()&#123; count++; console.log(count);&#125;var func = throttle(myFunc,100);window.onresize = function()&#123;func();&#125; 3.3 解决方案3深入理解 真正的节流应该是在可接受的范围内尽量延迟这个调用时间，也就是我们自己控制这个执行频率。因此可以增加一个必须执行时间 1234567891011121314151617181920212223var throttle = function(fn,delay,mustRunDelay)&#123; var timer = null; var t_start; return function()&#123; var context = this, args = arguments, t_curr = +new Date(); clearTimeout(timer); if(!t_start)&#123; t_start = t_curr; &#125; if(t_curr - t_start &gt;= mustRunDelay)&#123; fn.apply(context,args); t_start = t_curr; &#125; else &#123; timer = setTimeout(function()&#123; fn.apply(context,args); &#125;,delay) &#125; &#125;&#125; 参考来源 浅谈javascript的函数节流]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[安全的构造函数]]></title>
      <url>%2F2016%2F11%2F29%2Fsafe-constuctor%2F</url>
      <content type="text"><![CDATA[1. 概念安全的构造函数可以避免在全局作用域内调用函数构造函数，由于没有使用new，导致在全局作用域添加冗余的属性，同时还没有得到正确的执行结果。 2. 示例1234567891011//Globalfunction Person(name,age,job)&#123; this.name = name; this.age = age; this.job = job;&#125;//没有使用newvar person = Person('zhang',26,'font-end');console.log(window.name);//'zhang'console.log(window.age);//26 上述代码在严格模式下，运行会出错 因此，需要在函数里面确认this对象是正确类型的实例： 1234567function Person(name)&#123; if(this instanceof Person)&#123; this.name = 'zhang'; &#125; else &#123; return new Person(name) &#125;&#125; 3. 参考 《JavaScript高级程序设计》]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[函数柯理化]]></title>
      <url>%2F2016%2F11%2F29%2Fcurry%2F</url>
      <content type="text"><![CDATA[1. 概念函数柯里化（function currying），它用于创建已经设置好了一个或多个参数的函数。它是与函数绑定紧密相关的主题。 2. 创建柯里化函数调用另一个函数，并为它传入要柯里化的函数和必要参数。 12345678function curry(fn)&#123; var args = Array.prototype.slice.call(arguments,1); return function()&#123; var innerArgs = Array.prototype.slice.call(arguments); var finalArgs= args.concat(innerArgs); return fn.apply(null,finalArgs); &#125;&#125;; 示例：创建一个第一个参数绑定为3的add()的柯里化的版本 123function add(n1,n2)&#123;return n1 + n2;&#125;var curriedAdd = curry(add,3);console.log(curriedAdd(5));//8 3. 柯里化与函数绑定的结合函数柯里化常常作为函数绑定的一部分包含在其中，构造出更为复杂的bind()函数。 12345678function bind(fn,context)&#123; var args = Array.prototype.slice.call(arguments,1); return function()&#123; var innerArgs = Array.prototype.slice.call(arguments); var finalArgs = args.concat(innerArgs); return fn.apply(context,finalArgs); &#125;&#125; 这样的bind()函数不仅可以返回绑定给定环境的函数，并且可能绑定其中的某些函数参数。 4. 总结 ECMAScript5的bind()方法实现了函数柯里化。 无论是柯里化函数或是绑定函数，都会带来额外的开销，所以不应滥用。 5. 参考 《JavaScript高级程序设计》]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[函数作用域绑定]]></title>
      <url>%2F2016%2F11%2F29%2Fbind%2F</url>
      <content type="text"><![CDATA[1. 概念函数作用域绑定是一个常见的js技巧，常常和回调函数与事件处理一起使用，以便在将函数作为变量传递的同时保留代码执行环境。 很多JavaScript库实现了一个可以将函数绑定到指定环境的函数，这个函数一般都叫做bind()。一个简单的bind()函数接受一个函数和一个环境，并返回一个给的环境中调用给定函数的函数，并且将所有参数原封不动传递过去。这个函数返回的是一个闭包。 2. 原生实现12345function bind(fn,context)&#123; return function()&#123; fn.apply(context,arguments); &#125;;&#125; ECMAScript5为所有函数定义了一个原生的bind()方法，进一步简单了操作。 1fn.bind(this); 3. 参考 《JavaScript高级程序设计》]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2014阿里前端笔试题]]></title>
      <url>%2F2016%2F11%2F28%2Finterview-11%2F</url>
      <content type="text"><![CDATA[2014阿里前端笔试题 来源： – 题目js 现有代码，问输出和输出顺序 1234567891011121314function test()&#123; var a = 1; setTimeout(function()&#123; alert(a); a = 3; &#125;,1000); a = 2; setTimeout(function()&#123; alert(a); a = 4; &#125;,3000);&#125;test();alert(0); 考察点：定时器，event loop，闭包 setTimeout()只是将任务添加到任务队列中而已，要等到主执行栈中的代码执行完之后，才会调用定时器中的回调函数。 0 2（闭包，当test执行完成之后，a为2） 3（闭包，第一个定时器执行完之后，修改了a的值为3） 请编写一段程序，将一个对象和它直接、间接引用的所有对象的属性字符串放入一个数组，如var o = {a:1,b:2,c:{d:1}}，这里o经过处理后，应该得到[‘a’,’b’,’c’,’d’] 考察点：递归，for in 123456789101112var arr = [];function getAllProperties(o)&#123; if(o &amp;&amp; typeof o === 'object')&#123; for(var k in o)&#123; arr.push(k+''); if(typeof o[k] === 'object')&#123; getAllProperties(o[k]); &#125; &#125; &#125;&#125;console.log(arr); 返回一个合并过的数组（归并操作） var a = [-3,-1,0,1,3,5,7,9], b = [-4,-2,0,2,3,4,5,6,7,8]，返回[-4,-3,-2,-1,0,0,1,2,3,3,4,5,5,6,7,7,8,9] 123456789101112131415function merge(a,b)&#123; var tmp = [], i = 0,j = 0, lenA = a.length,lenB = b.length; while(i &lt; lenA &amp;&amp; j &lt; lenB)&#123; if(a[i] &lt;= b[j])&#123; tmp.push(a[i++]); &#125; else &#123; tmp.push(b[j++]); &#125; &#125; while( i &lt; lenA)tmp.push(a[i++]); while( j &lt; lenB)tmp.push(b[j++]); return tmp;&#125; 当我们使用CSS3新属性，比如：box-shadow或者transition时，我们怎么检测浏览器是否支持这些属性？请设计一个JavaScript函数，该函数接受一个CSS属性名作为参数，并返回一个boolean值，表明浏览器是否支持这个属性。 考察点：el.style属性，兼容的前缀（ktml,ms,moz,webkit） 1234567891011121314151617181920var support = function(prop)&#123; var div = document.createElement('div'), vendors = 'ktml,ms,moz,webkit'.split(','), len = vendors.length, tmp; var propArr = prop.split('-'); for(var i = 1; i &lt; propArr.length; i++)&#123; propArr[i] = propArr[i].charAt(0).toUpperCase() + propArr[i].substring(1); &#125; prop = propArr.join(''); if(prop in div.style)return true; while(len--)&#123; tmp = vendors[len] + prop.charAt(0).toUpperCase() + prop.substring(1); if( tmp in div.style)return true; &#125; return false;&#125; 写一段脚本，实现：当页面上任意一个链接被点击的时候，alert出这个链接在页面上的顺序号，如第一个链接则alert(1), 依次类推； 考察点：闭包，document.links 12345678910window.onload = function()&#123; var len = document.links.length; for(var i = 0; i &lt; len;i++)&#123; document.links[i].onclick = (function(i)&#123; return function()&#123; return i+1; &#125; &#125;)(i); &#125;&#125; html/css 下图绿色区域的宽度为100%，其中有三个矩形，第一个矩形的宽度是200px，第二个和第三个矩形的宽度相等。请使用CSS3中的功能实现它们的布局。 已知HTML结构是 12345&lt;div class="box"&gt; &lt;div&gt;column 1&lt;/div&gt; &lt;div&gt;column 2&lt;/div&gt; &lt;div&gt;column 3&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728.box&#123; width:100%; height:50px; display:-moz-box; display:-webkit-box; display:box; background:green;&#125;.box div&#123; background:rgba(236, 224, 224, 0.82); height:40px; line-height:40px; text-indent:2em;&#125;.box div&#123; -moz-box-flex:1; -webkit-box-flex:1; box-flex:1; margin-right:5px; margin-top:5px;&#125;.box div:first-child&#123; width:200px; margin-left:5px; -moz-box-flex:0; -webkit-box-flex:0; box-flex:0;&#125; 有两个盒子 A、B，B 在 A 盒子中，它们的 CSS 是这么定义的： 123456789101112.A &#123; position:relative; width:500px; height: 500px; background-color:green;&#125;.B &#123; position:absolute; max-width:300px; max-height:300px; background-color:blue;&#125; 如何实现 B 在 A 中水平方向和垂直方向居中?这道题的问题在于B是没有固定宽度和高度的。 123&lt;div class=&quot;A&quot;&gt; &lt;div class=&quot;B&quot;&gt;这是B&lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021.A&#123; position:relative; width:500px; height: 500px; background-color:green; display:-moz-box; display:-webkit-box; display:box; -moz-box-align:center; -webkit-box-align:center; box-align:center; -moz-box-pack:center; -webkit-box-pack:center; box-pack:center;&#125;.B&#123; /* position:absolute; 如果这个属性存在，则设置box-* 无效*/ max-width:300px; max-height:300px; background-color:blue;&#125; 请用html5标准完成以下页面布局（要求完整书写整个页面的html代码，不需要写CSS） 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;demo&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;header&gt;&lt;/header&gt; &lt;nav&gt;&lt;/nav&gt; &lt;div&gt; &lt;aside&gt;&lt;/aside&gt; &lt;section&gt;&lt;/section&gt; &lt;/div&gt; &lt;footer&gt;&lt;/footer&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[BAT2014前端笔试面试题-中级篇]]></title>
      <url>%2F2016%2F11%2F28%2Finterview-10%2F</url>
      <content type="text"><![CDATA[BAT2014前端笔试面试题-中级篇 来源：http://blog.jobbole.com/78738/ 题目 实现一个函数clone，可以对JavaScript中的5中主要类型进行进行值复制。 考察点：参数传递，类型检测，递归 1234567891011121314151617181920212223242526function clone(obj)&#123; if(obj === null)&#123; return null; &#125; if(obj === undefined)&#123; return (void 0); &#125; if(typeof obj !== 'object')&#123; //number,string return obj; &#125; var o; //是否是数组 if(Object.prototype.toString.call(obj) === '[object Array]')&#123; o = []; &#125; else &#123; o = &#123;&#125;; &#125; for(var i in obj)&#123; o[i] = clone(obj[i]); &#125; return o;&#125; 如何消除一个数组里面的重复元素 123456789101112function unique(a)&#123; if(Array.isArray(a))&#123; var len = a.length,item; while(len--)&#123; item = a.shift(); if(a.indexOf(item) === -1)&#123; a.push(item); &#125; &#125; &#125; return a;&#125; 小贤是一条可爱的小狗(Dog)，它的叫声很好听(wow)，每次看到主人的时候就会乖乖叫一声(yelp)。从这段描述可以得到以下对象： 123function Dog()&#123;&#125;Dog.prototype.wow = function()&#123;console.log('wow');&#125;Dog.prototype.yelp = function()&#123;console.log('yelp');&#125; 小芒和小贤一样，原来也是一条可爱的小狗，可是突然有一天疯了(MadDog)，一看到人就会每隔半秒叫一声(wow)地不停叫唤(yelp)。请根据描述，按示例的形式用代码来实现 考察点：继承，定时器，原型链，this 12345678910111213function MadDog()&#123;&#125;;MadDog.prototype = new Dog();MadDog.prototype.yelp = function()&#123; var self = this; setInterval(function()&#123; self.wow(); &#125;,500);&#125;;var dog = new Dog();dog.yelp();var madDog = new MadDog();madDog.yelp(); 下面这个ul，如何点击每一列的时候输出其index 12345&lt;ul id="test"&gt; &lt;li&gt;这是第一条&lt;/li&gt; &lt;li&gt;这是第二条&lt;/li&gt; &lt;li&gt;这是第三条&lt;/li&gt;&lt;/ul&gt; 考察点：闭包！！！ 12345678var lis = document.getElementsByTagName(li);for(var i = 0, len = lis.length; i &lt; len; i++)&#123; lis[i].onclick = (function(index)&#123; return function()&#123; alert(index); &#125; &#125;)(i);&#125; 编写一个JavaScript函数，输入指定类型的选择器(仅需支持id，class，tagName三种简单CSS选择器，无需兼容组合选择器)可以返回匹配的DOM节点，需考虑浏览器兼容性和性能。 考察点：捕获组（[全部,捕获组1,捕获组2,…]），数组化（IE8及更早） 12345678910111213141516171819202122232425262728293031323334var query = function(selector)&#123; var pattern = /^(#)?(\.)?(\w+)?/ig; var matches = pattern.exec(selector); var results = []; //将节点类数组进行转化 var list,len,i; if(!matches[3])&#123; throw new Error('invalid selector'); &#125; //id选择器 if(matches[1])&#123; if(document.getElementById)&#123; return document.getElementById(matches[3]); &#125; else if(document.all)&#123; return document.all[matches[3]]; &#125; else &#123; throw new Error('no id selector'); &#125; &#125; //class选择器 if(matches[2])&#123; if(document.getElementsByClassName)&#123; list = document.getElementsByClassName(matches[3]); &#125; else &#123; var allDoms = document.getElementsByTagName('*'); var domArr = Array.prototype.slice.call(allDom); for(i = 0, len = domArr.length; i &lt; len; i++)&#123; if(domArr[i].className === matches[]) &#125; &#125; &#125;&#125; 【事件监听】请评价以下代码并给出改进意见。 123456789101112if(window.addEventListener)&#123; var addListener = function(el,type,listener,useCapture)&#123; el.addEventListener(type,listener,useCapture); &#125;;&#125;else if(document.all)&#123; addListener = function(el,type,listener)&#123; el.attachEvent("on"+type,function()&#123; listener.apply(el); &#125;); &#125;&#125; document.all是特性推断，是种不好的做法，应该改为特性检测，需要啥检测啥 有可能浏览器并不支持以上的两者形式，还有更多的可能没有考虑到。 attachEvent的事件处理函数是在全局作用域调用，因此this是指向window 并没有提供统一的接口 可以利用惰性加载的机制来改进，避免过多的检测 考察点：事件监听处理，兼容性，惰性加载，特性检测，attachEvent 1234567891011121314151617181920function addListener(el,type,listener)&#123; if(el.addEventListener)&#123; addListener = function(el,type,listener)&#123; el.addEventListener(type,listener,false); &#125; &#125; else if(el.attchEvent)&#123; addListener = function(el,type,listener)&#123; el.attachEvent('on'+type,function()&#123; //处理attachEvent事件处理函数的作用域问题 listener.call(el); &#125;); &#125; &#125; else &#123; addListener = function(el,type,listener)&#123; el['on' + type] = listener; &#125; &#125; //绑定事件，第一次才会执行 addListener(el,type,listener);&#125; 给String对象添加一个方法，传入一个string类型的参数，然后将string的每个字符间加个空格返回，例如：addSpace(“hello world”) // -&gt; ‘h e l l o w o r l d’ 考察点：split,join 123function addSpace(s)&#123; return s.split('').join(' ');&#125; 直接给对象原型添加方法是不安全的做法，这也是为什么prototype.js后来陨落的原因。会给开发和维护带来很大的麻烦。 函数声明和函数表达式 在js中，解析器在解析的时候，会率先读取函数声明，并使其在执行任何代码之前可以用，至于函数表达式要等到解析器执行到所在的代码行，才会真正被执行。 1234add(1,2); //报错！！var add = function(v1,v1)&#123;return v1 + v2;&#125;sum(1,2); //3,正常执行function sum(v1,v2)&#123;return v1 + v2;&#125; 定义一个log方法，让它可以代理console.log的方法 123function log()&#123; console.log.apply(console,arguments);&#125; apply和call的作用是切换函数对象的上下文，通过第一个参数来指定，也就是this的指向，不同之处就是传入的参数不同，call适合一两个参数，apply适合数组。 在JavaScript中什么是伪数组？ NodeList，HTMLCollection，arguments，可以向数组一样的遍历，但是却不能使用数组的方法。 123function toArray(obj)&#123; return Array.prototype.slice.call(obj);&#125; 对作用域上下文和this的理解，看下列代码： 1234567891011var User = &#123; count: 1, getCount: function() &#123; return this.count; &#125;&#125;;console.log(User.getCount());// what?var func = User.getCount;console.log(func()); //what? 第一个输出：1,作用域是User第二个输出：undefined,作用域是全局，而全局作用域里没有count变量 那么如何确保User总是能访问到func的上下文，确保返回1 1234567Function.prototype.bind = Function.prototype.bind || function(context)&#123; var self = this; return function()&#123; self.apply(context,arguments); &#125;&#125;var fnc = User.getCount.bind(User); 原生的window.onload与jQuery的$(document).ready(function(){})有什么不同，如何用原生的JavaScript实现jQuery的ready方法？ 内在原理 load事件：必须要等到页面所有元素（包括图片）加载完成之后才会触发 DOMContentLoaded事件：在DOM结构绘制完成之后就会触发 使用 window.onload只能指定一个回调函数（多个会覆盖） ready()能够指定多个 想实现一个对页面某个节点的拖拽？如何做？（原生的JS） 给需要拖拽的节点绑定mousedown，mousemove，mouseup事件 当mousedown事件触发后，开始拖拽 mousemove阶段，通过event.clientX和event.clientY获取拖拽位置，并实时更新位置 mouseup时，拖拽结束 需要注意浏览器边界的情况 说出一下函数的作用是？空白区域应该填写什么？ 12345678910111213141516171819//define(function(window)&#123; function fn(str)&#123; this.str=str; &#125; fn.prototype.format = function()&#123; var arg = ______; return this.str.replace(_____,function(a,b)&#123; return arg[b]||""; &#125;); &#125; window.fn = fn;&#125;)(window);//use(function()&#123; var t = new fn('&lt;p&gt;&lt;a href="&#123;0&#125;"&gt;&#123;1&#125;&lt;/a&gt;&lt;span&gt;&#123;2&#125;&lt;/span&gt;&lt;/p&gt;'); console.log(t.format('http://www.alibaba.com','Alibaba','Welcome'));&#125;)(); 作用是：模版替换 空白区域： Array.prototype.slice.call(arguments) /{\d+}/g]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[BAT2014前端笔试面试题-初级篇]]></title>
      <url>%2F2016%2F11%2F28%2Finterview-09%2F</url>
      <content type="text"><![CDATA[BAT2014前端笔试面试题-初级篇 来源：http://blog.jobbole.com/78738/ 题目 JavaScript的数据类型有哪些？ 基本类型：number,string,boolean,undefined,null 对象类型：Object 如何判断数组类型 123function isArray(arr)&#123; return Object.prototype.toString.call(arr) === '[object Array]';&#125; 已知ID的Input输入框，希望获取这个输入框的输入值，怎么做？ 1document.getElementById(id).value 希望获取到页面中所有的checkbox怎么做？ 1&lt;input type="checkbox" value="male"/&gt;男 12345678var domList = document.getElementsByTagName('input');var checkList = [];var len = domList.length;while(len--)&#123; if(domList[len].type === 'checkbox')&#123; checkList.push(domList[len]); &#125;&#125; 设置一个已知ID的DIV的html内容为xxxx，字体颜色设置为黑色 123var div = document.getElementById('id');div.innerHTML = 'xxxx';div.style.color = '#000'; 当一个DOM节点被点击时候，我们希望能够执行一个函数，应该怎么做？ 有三种方式 直接在DOM里面绑定事件 通过onclick绑定事件处理函数 通过addEventListener\attachEvent DOM事件流的三个阶段 事件捕获 目标阶段 事件冒泡 看下列代码输出为何？解释原因。 考察点：undefined 123var a;alert(a);alert(b); a声明了，但未赋值，因此输出为:undefined；b未声明，会报错。 看下列代码,输出什么？解释原因。 12var a = null;alert(typeof a); 返回:object,实际上可以理解为空指针对象。 看下列代码,输出什么？解释原因。 考察点：隐式类型转换 12345678910var undefined;undefined == null;1 == true;2 == true;0 == false;0 == '';NaN == NaN;[] == false; //true[] == ![]; //true[] == []; //false undefined == null为true，但是undefined === null为false 大于0的数字，与true相等 大于0的数字，与true相等 0 与 ‘’ 与 false相等 0 与 ‘’ 与 false相等 NaN不与任何相等，包括它本身 Number([])为0，因此 [] == 0为true，且0 == false为true，因此[] == false为true。此外Number([9]) == 9 因为![]为false，且[] == false为true，因此结果为false 前一个数组和后一个数组是不同的对象 123var foo = '11' + 2 -'1';console.log(foo); //11console.log(typeof foo); //number 由于运算符的优先级一样，所以先运算&#39;11&#39; + 2，结果为&#39;112&#39;，再运算&#39;112&#39; - &#39;1&#39;，由于字符串没有减法操作，因此会转为number类型进行运算，结果为11，foo的类型也为number 看代码给答案。 考察点：引用类型 12345var a = new Object();a.value = 1;b = a;b.value = 2;alert(a.value); //2 已知有字符串foo=”get-element-by-id”,写一个function将其转化成驼峰表示法”getElementById” 考察点：split(),charAt(),toUpperCase(),substring(),join() 1234567function combo(msg)&#123; var arr = msg.split('-'); for(var i = 1, len = arr.length; i &lt; len; i++)&#123; arr[i] = arr[i].charAt(0).toUpperCase() + arr[i].substring(1); &#125; return arr.join('');&#125; var numberArray = [3,6,2,4,1,5]; 1)实现倒排；2）实现对该数组进行降序排列； 考察点：reverse(),sort(function()) 倒排 12var reverseArr = numberArray.reverse();console.log(reverseArr); 降序排列 12numberArray.sort(function(v1,v2)&#123;return -(v1-v2)&#125;);console.log(numberArray); 输出今天的日期，以YYYY-MM-DD的方式，比如今天是2014年9月26日，则输出2014-09-26 考察点：Date,getFullYear(),getMonth(),getDate() 123456789var d = new Date();var year = d.getFullYear(), month = d.getMonth() + 1, day = d.getDate() + 1;month = month &gt;= 10 ? month : '0' + month;day = day &gt;= 10 ? day : '0' + day;console.log(year + '-' + month + '-' + day); 将字符串”{$id}{$name}“中的{$id}替换成10，{$name}替换成Tony 考察点：正则表达式 123var str = '&lt;tr&gt;&lt;td&gt;&#123;$id&#125;&lt;/td&gt;&lt;td&gt;&#123;$name&#125;&lt;/td&gt;&lt;/tr&gt;';var newStr = str.replace(/\&#123;\$id\&#125;/g,'10').replace(/\&#123;\$name\&#125;/g,'Tony');console.log(newStr); 为了保证页面输出安全，我们经常需要对一些特殊的字符进行转义，请写一个函数escapeHtml，将&lt;, &gt;, &amp;, “进行转义 考察点：replace(pattern,function(match,pos,originText){}) 1234567891011121314function escapeHtml(test)&#123; return text.replace(/[&lt;&gt;"&amp;]/g,function(match)&#123; switch(match)&#123; case '&lt;': return '&amp;lt'; case '&gt;': return '&amp;gt'; case '&amp;': return '&amp;amp'; case '\"': return '&amp;quot'; &#125; &#125;);&#125; foo = foo || bar 这行代码的意思 考察点：||操作符 这叫短路求值，这段代码相当于 1if(!foo)foo = bar; 即如果foo不存在，则将bar赋值给foo 看下列代码，将会输出什么 考察点：变量提升(不会提升赋值部分)，作用域，变量查找 123456var foo = 1;(function()&#123; console.log(foo); var foo = 2; console.log(foo);&#125;)(); 这段代码相当于 1234567var foo = 1;(function ()&#123; var foo; console.log(foo); foo = 2; console.log(foo);&#125;)(); 因此输出就是:undefined,2 把两个数组合并，并删除第二个元素 考察点：concat(),splice() 1234var array1 = ['a','b','c'];var bArray = ['d','e','f'];var cArray = array1.concat(bArray);cArray.splice(1,1); 用js实现随机选取10–100之间的10个数字，存入一个数组，并排序。 考察点：随机生成数，random() 123456789var a = [],len = 10;function getRandom(start,end)&#123; var range = end - start; return Math.floor(Math.random() * range + start);&#125;while(len--)&#123; a.push(getRandom(10,100));&#125;a.sort(function(v1,v2)&#123;return v1 - v2;&#125;); 有这样一个URL：http://item.taobao.com/item.htm?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e，请写一段JS程序提取URL中的各个GET参数(参数名和参数个数不确定)，将其按key-value形式返回到一个json结构中，如{a:&#39;1‘, b:’2’, c:’’, d:’xxx’, e:undefined}。 1234567891011121314151617function getJson(url)&#123; var a = url.split('?'), objArr = a[1].split('&amp;'), json = &#123;&#125;, tmp = [], i,len; for(i = 0, len = objArr.length;i &lt; len; i++)&#123; tmp = objArr[i].split('=');//c=也会返回['c',''] if(tmp.length === 1)&#123; //即出现没有=等情况 json[tmp[0]] = void 0; &#125; else &#123; json[tmp[0]] = tmp[1]; &#125; &#125; return json;&#125; 看下面代码 12345for(var i=1;i&lt;=3;i++)&#123; setTimeout(function()&#123; console.log(i); &#125;,0);&#125;; 因为setTimeout(fn,0)只是将任务放在任务队列里面，并不是马上执行，要等到for循环执行完毕之后，由于里面是三个闭包，都引用了i变量，执行完for循环之后，i的值为4，因此就输出：4,4,4 要想输出1，2，3，则 1234567for(var i = 1;i &lt;= 3; i++)&#123; (function(i)&#123; setTimeout(function()&#123; console.log(i); &#125;,0); &#125;)(i);&#125; 写一个function，清除字符串前后的空格 123function trim(s)&#123; return s.replace(/^\s+|\s+$/g,'');&#125; 正则表达式构造函数var reg=new RegExp(“xxx”)与正则表达字面量var reg=//有什么不同？匹配邮箱的正则表达式？ 当使用RegExp()构造函数的时候，不仅需要转义引号（即\”表示”），并且还需要双反斜杠（即\表示一个\）。使用正则表达字面量的效率更高。 邮箱的正则表达式？ JavaScript中callee和caller的作用 caller是返回一个调用当前函数的函数的引用 callee是返回正在执行的函数体 如果一对兔子每月生一对兔子；一对新生兔，从第二个月起就开始生兔子；假定每对兔子都是一雌一雄，试问一对兔子，第n个月能繁殖成多少对兔子？（使用callee完成）（实际上就是斐波那契数列） 123456function fn(n)&#123; if (n === 1 || n === 2 )return 1; else &#123; return arguments.callee(n-1) + arguments.callee(n-2); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2016年Web前端面试题目汇总]]></title>
      <url>%2F2016%2F11%2F28%2Finterview-08%2F</url>
      <content type="text"><![CDATA[2016年Web前端面试题目汇总 来源：http://www.cnblogs.com/bigboyLin/p/5272902.html 题目HTML &amp; CSS 什么是盒子模型 在网页中，一个元素占有空间的大小由几大部分构成 元素的内容（content） 元素的内边距（padding） 元素的边框（border） 元素的外边距（margin） 这四个部分构成一起构成css的盒模型 行内元素有哪些？块级元素？空（void）元素？ 行内元素 a，img，input，span，textarea，button，em，select，label 块级元素 div，ul，lu，dt，dl，dd，h1-h6，blockquote 空（void）元素 没有内容的HTML元素，br，meta，hr，link，img CSS实现垂直水平居中 123&lt;div class="wrapper"&gt; &lt;div class="content"&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011.wrapper&#123;position:relative;&#125;.content&#123; width : 200px; height: 200px; background : red; position : relative; top:50%; left:50%; margin-left : -100px; margin-top : -100px;&#125; 简述一下src和href的区别 含义不同 src：外部资源；href：超链接 作用不同 src：下载资源后嵌入到标签元素的位置；href：建立链接 下载效果不同 src：阻塞的，直到资源下载，解析，处理之后； href：不会，一边下载，一边解析文档。 什么是CSS Hack？ 一般来说是针对不同浏览器写不同的css，就是css hack。IE浏览器hack分为： 条件hack 属性hack 选择符hack 同步和异步的区别 同步是阻塞模式 同步就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程会一直等待下去，直到收到返回信息才继续执行下去。 异步是非阻塞模式 异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时，系统会通知进程进行处理，这样可以提高执行的效率。 px和em的区别 两者都是长度单位 px的值是固定的。 em的值不是固定，而且会继承父级元素的字体大小。 浏览器默认的字体高都是16px。所以未经过调整的浏览器都符合1em=16px 优雅降级和渐进增强 浏览器内核 IE：trident Firefox：gecko Safari：Webkit Chrome：Blink（基于Webkit） Opera：Blink（以前presto） JavaScript 怎么添加、移除、移动、复制、创建和查找节点 创建 123document.createElement(tagName);//具体元素document.createTextNode(string);//文本节点document.createDocumentFragment();//文档片段 添加、移除、替换、插入 1234parent.appendChild(el);//添加parent.removeChild(el);//移除parent.replaceChild(newNode,oldNode);//替换insertBefore(childNode,ref-node/null);//插入 查找 1234document.getElementById(id);//iddocument.getElementsByTagName(tagName);//tagNamedocument.getElementsByName(name);//namedocument.getElementsByClassName(class);//className 实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制。 首先，这道题是有点问题的，在js中，函数参数传递都是值复制，因此只要 123function clone(obj)&#123; return obj;&#125; 指的是深复制（存在于引用类型） 类型检测typeof\instanceof 递归的思想 12345678910111213141516171819202122232425function clone(obj)&#123; if(obj === null)&#123; return null; &#125; if(obj === undefined)&#123; return (void 0); &#125; if(typeof obj !== 'object')&#123; //number,string return obj; &#125; var o; //是否是数组 if(Object.prototype.toString.call(obj) === '[object Array]')&#123; o = []; &#125; else &#123; o = &#123;&#125;; &#125; for(var i in obj)&#123; o[i] = clone(obj[i]); &#125; return o;&#125; 消除数组中重复的元素 123456789101112function unique(array)&#123; if(Object.prototype.toString.call(array) === '[object Array]')&#123; var item,i,len; for(i = 0, len = array.length; i &lt; len; i++)&#123; item = array.shift(); if(array.indexOf(item) === -1)&#123; array.push(item); &#125; &#125; return array; &#125;&#125; 实现对一个页面某个节点的拖拽？（原生实现） 在JavaScript中什么是伪数组？如何将伪数组转化为标准数组？ 伪数组，又叫做类数组，可以像真正的数组一样来遍历，但是无法直接调用数组方法，且length属性也没有什么特别的行为。 常见的伪数组有arguments,NodeList,HTMLCollection等 1var arr = Array.prototype.slice.call(likeArray); Javascript中的callee和caller的作用 caller是返回调用此函数的函数 callee返回的是正在执行的function函数 cookies，sesstionStorage，locaStorage的区别 大小 HTTP请求是否携带 操作简易 手写数组快速排序 统计字符串”aaaabbbccccddfgh”中的字母个数或统计最多字母数 123456789101112131415161718192021function max(s)&#123; var map = &#123;&#125;,index = s.charAt(0), c,i,len; for(i = 0, len = s.length; i &lt; len; i++)&#123; c = s.charAt(i); if(!map[c])&#123; map[c] = 1; &#125; else &#123; map[c]++; if(map[index] &lt; map[c])&#123; max = c; &#125; &#125; &#125; return &#123; max : map[index], index : index &#125;;&#125; 写一个函数，清除字符串前后的空格(兼容所有浏览器) 12345function trim(str)&#123; if (str &amp;&amp; typeof str === 'string')&#123; return str.replace(/(^\s+)|(\s+$)/g,'') &#125;&#125; 其他 一次完整的HTTP是怎么的一个过程 输入url dns解析 若有缓存，直接读取 没有则进行dns查询 发起TCP3次握手，建立TCP连接 客户端发送SYN=1，Seq=x+1， 服务器端发送SYN=1，Seq=y+1，ACK=x+1 客户端发送ACK=y+1，Seq=x+2 在建立完连接之后，发送HTTP请求 服务器端响应HTTP请求，返回页面 浏览器获取页面，进行解析 HTML转化为DOM CSS代码转化成CSSOM 结合DOM和CSSOM，生成渲染树 生成布局，将所有渲染树的节点进行平面合成 将布局绘制在屏幕上 浏览器显示页面]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[BAT2014前端笔试面试题]]></title>
      <url>%2F2016%2F11%2F28%2Finterview-07%2F</url>
      <content type="text"><![CDATA[BAT2014前端笔试面试题 来源：http://www.cnblogs.com/coco1s/p/4034937.html 题目HTML 篇 你做的页面在哪些流览器测试过？这些浏览器的内核分别是什么? IE：trident内核 Firefox：gecko内核 Safari：Webkit内核 Opera：Blink内核（以前是presto内核） Chrome：Blink（基于Webkit） 每个HTML文件里开头都有个很重要的东西，Doctype，知道这是干什么的吗？ 最重要的作用是告诉浏览器按照何种规范来解析页面，对页面的布局呈现有很大影响 Quirks模式是什么？它和Standards模式有什么区别 怪异模式是IE弄出来的东西，会影响布局和css样式的解析 div+css的布局较table布局有什么优点？ 表现与结构相分离 页面加载速度更快，结构更清晰，页面显得简洁 易于优化，对搜索引擎更友好 a：img的alt与title有何异同？b：strong与em的异同？ alt：如果不能显示图片，alt属性用来指定替换文字，还有就是阅读屏幕的时候，可以阅读出来。 title：该属性为设置该属性的元素提供建议性的信息。 strong：粗体标签，表示内容的重要性 em：斜体标签，表示内容的强调点 优雅降级和渐进增强 优雅降级：使用新特性，如css3的新属性，来丰富页面的效果，再针对低版本的浏览器进行兼容 渐进增强：针对低版本浏览器进行页面构建，保证基本的功能的情况下，再针对高级浏览器等改进和追加功能来达到更好的用户体验。 为什么利用多个域名来存储网站资源会更有效？ CDN缓存会更加方便 突破浏览器的并发限制 节约cookie带宽 节约主域名的连接数，优化页面响应速度 防止不必要的安全问题 请谈一下你对网页标准和标准制定机构重要性的理解。 标准是一个行业健康发展的保证，而且从一个开发者来说，看看前端的历史就知道由于先前的浏览器之争，给开发带来多大的麻烦，光顾着解决兼容性的问题，导致无法专注于业务，提高用户体验这些更为重要的事情上。不过如今，浏览器之争趋于平缓，标准被越来越广泛地接受。 请描述一下cookies，sessionStorage和localStorage的区别？ cookie 大小限制4Kb， 发送请求会携带cookie 不能跨域调用 cookie的操作也很麻烦 seesionStorage &amp; localStorage 更大容量 更加便捷的操作API 不会在请求中携带 一个是会话级别的存储，一个持久化的本地存储 简述一下src与href的区别。 src 是source的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签的所在位置。 当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到该资源加载、编译、执行完毕。这也是为什么要把js脚本放置到底部的原因。 href Hypertext Reference的缩写，指向网络资源的所在位置，建立和当前元素（锚点）或当前文档（链接）之间的连接。 1&lt;link href="common.css" rel="stylesheet"&gt; 浏览器会识别该文档为css文件，就会并行下载资源并且不会停止对当前文档的处理。这也是link方式比@import方式好的原因。 页面中的图片格式有哪些 png，jpeg，gif，svg Webp：谷歌开发的一种旨在加快图片加载速度的图片格式，图片压缩体积比jpeg的小很多，可以节省大量的服务器带宽资源和数据空间。 微格式？ 微格式（Microformats）是一种让机器可读的语义化XHTML词汇的集合，是结构化数据的开发标准，为特殊应用而指定的特殊格式。 优点：可以让网站内容在搜索引擎结果界面可以显示额外的提示。 一次js请求一般情况下有哪些地方会有缓存处理？ dns缓存 cdn缓存 浏览器缓存 服务器缓存 一个页面上有大量的图片（大型电商网站），加载很慢，如何优化 图片懒加载 在页面上添加一个滚动条事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载 图片预加载 像页面中的幻灯片，相册 雪碧图 如果有小图居多，可以进行图片合并，制成雪碧图 预加载缩略图 如果图片过大，可以使用特殊编码的图片，加载时先加载一张压缩的特别厉害的缩略图，以提高用户体验。 图片展示区和图片大小保持一致。 CSS篇 有哪些方式可以对一个DOM设置它的CSS样式 外部样式，引入一个css文件 内部样式，将css代码写在&lt;style&gt;标签内 内联样式，写在DOM元素的style属性内 CSS都有哪些选择器 元素选择器 id选择器 类选择器 属性选择器 优先级的定义： 特殊性 重要性 来源 顺序（声明的先后顺序） 问题 12345&lt;style&gt; .a &#123;color:blue;&#125; .b &#123;color:red;&#125;&lt;/style&gt;&lt;p class="b a"&gt;123&lt;/p&gt; 输出结果是:red，样式定义的在文件中的先后顺序有关，而跟使用的先后无关。 CSS中可以通过哪些属性定义，使得一个DOM元素不显示在浏览器的可视范围内 display:none visibilty : hidden width:0 height:0 opacity:0 z-index:-1000 行内元素和块级元素区别，还有inline-block 外边距重叠 在CSS中，相邻的两个盒子的外边距可以结合成一个单独的外边距，这种合并外边距的方式被称为折叠。 折叠计算规则： 两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值 两个外边距一正一负时，折叠结果是两者相加的和 rgba()和opacity的透明效果有什么不同 rgba()和opacity都能实现透明效果 opacity作用于元素，以及元素内的所有内容的透明度 rgba()只作用于元素的颜色或其背景色（子元素不会继承透明效果） css中可以让文字在垂直和水平方向上重叠的两个属性是什么 垂直方向：line-height 水平方向：letter-spacing letter-spaceing的妙用： 可以用于消除inline-block元素间的换行符空格间隙问题 如何垂直居中一个浮动元素 px和em的区别 px和em都是长度单位，但是px是固定值，而em不是，而且em会继承父级元素的字体大小。 默认情况下，浏览器的字体大小为16px，即1em=16px 描述一个resetcss文件并如何使用它，知道normalize.css？ 重置样式是为了去除掉浏览器的默认的样式，让浏览器达到一致和合理。但是由于重置样式重置了所有的默认样式，过于”粗暴”。于是就出现了改良版的normalize.css，它没有重置所有的样式风格，但有提供了一套合理的默认样式值。在让浏览器达到一致的同时，又不扰乱其他的东西。 Sass、Less是什么 它们是css预处理器，是在css上的一层抽象。它们的好处 结构清晰，便于扩展 可以方便地屏蔽浏览器私有语法差异，减少无意义的机械劳动 完全兼容css代码。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2015奇虎360面试题]]></title>
      <url>%2F2016%2F11%2F28%2Finterview-06%2F</url>
      <content type="text"><![CDATA[2015奇虎360面试题 来源：http://www.wtoutiao.com/p/n279i7.html 题目1. js 下面代码的输出值是 alert(1 &amp;&amp; 2) 考察点：&amp;&amp; 和 || 逻辑运算符运算符 关系表达式的优先级比&amp;&amp;和||都高 他们不一定都返回布尔值，而是返回运算结果，然后（如果需要）再进行隐性类型转换 &amp;&amp;如果左运算为真的话，一定会再进行右运算 ||如果左运算为真的话，则停止 因此结果为：2 同样，如果 alert( 1 || 2) 结果为：1 正则表达式匹配，开头为11N, 12N或1NNN，后面是-7-8个数字的电话号码 考察点：正则表达式，\d，{n,m}，(X)? 1234var d = ['11N2321234','12N12311234','1NNN1234456','2N2123411','11N12343','11N2343234NN'];for(var i in d)&#123; console.log(d[i].match(/^(11N|12N|1NNN)\d&#123;7,8&#125;$/g));&#125; 只能说在这个测试数据集是对的 写出下面代码的输出值 12345678910var obj = &#123; a: 1, b: function () &#123;console.log(this.a)&#125;&#125;;var a = 2;var objb = obj.b;obj.b();objb();obj.b.call(window); 考察点：this，全局作用域，call 结果： obj.b()：此时this-&gt;obj，因此输出：1 objb()：由于是在全局作用域调用，this-&gt;window，因此输出结果为：2 obj.b.call(window)：由于call的作用，this-&gt;window，因此输出结果为：2 写出下列代码的输出值 12345678910111213141516171819function A() &#123;&#125;function B(a) &#123; this.a = a;&#125;function C(a) &#123; if (a) &#123; this.a = a; &#125;&#125;A.prototype.a = 1;B.prototype.a = 1;C.prototype.a = 1;console.log(new A());console.log(new B());console.log(new C(2)); 考察点：原型链，变量查找原则 结果： new A()：因为A的实例没有a属性，会查找原型链，输出结果为：{} new B()：因为B的实例有a属性，输出B实例的a，没有初始化，输出结果为：{a:undefined} new C(2)：因为C的实例有a属性，且进行初始化，输出结果为：{a:2} 写出下列代码的输出值 1234567891011var a = 1;function b() &#123; var a = 2; function c() &#123; console.log(a); &#125; return c;&#125;b()(); 考察点：函数作用域，变量查找，闭包 结果： 由于在函数b内有a，函数c内使用的变量就是函数b内的a，c为一个闭包，输出结果为：2 2. HTML &amp; CSS 添加写CSS让其水平垂直居中 1&lt;div style = "text-align:center"&gt;居中&lt;/div&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端面试题集锦及答案]]></title>
      <url>%2F2016%2F11%2F28%2Finterview-05%2F</url>
      <content type="text"><![CDATA[前端面试题集锦及答案 来源：http://www.xuanfengge.com/front-end-analysis-of-collection-of-interview-questions-and-answers.html 题目 下面这段代码想要循环延时输出结果0 1 2 3 4,请问输出结果是否正确,如果不正确,请说明为什么,并修改循环内的代码使其输出正确结果 12345for(var i = 0; i &lt; 5; ++i)&#123; setTimeout(function()&#123; console.log(i + ' '); &#125;,100);&#125; 考察点：闭包，setTimeout，任务队列 分析：不能输出正确结果，因为setTimeout接受的参数函数会通过闭包访问变量i，因为js运行的环境为单线程，而setTimeout的作用是经过一段时间后，将任务添加到任务队列中，需要等待执行栈里面的代码执行完之后，才轮到setTimeout里面的回调函数执行，此时i的值为5，因此输出的是都是5. 1234567for(var i = 0; i &lt; 5; ++i)&#123; (function(i)&#123; setTimeout(function()&#123; console.log(i + ' '); &#125;,100); &#125;)(i);&#125; 请用代码写出（今天是星期x），其中x表示当天是星期几，如果当天是星期一，输出应该是：今天是星期一 考察点：Date对象的操作 123var days = ['日','一','二','三','四','五','六'];var date = new Date();console.log('今天是星期' + days[date.getDay()]); 编写javascript深度克隆函数deepClone 考察点：深克隆（浅克隆），Object，DOM Node，Date，RegExp对象属性,数组 12345678910111213141516171819202122232425262728293031323334353637function deepClone(obj)&#123; var _toString = Object.prototype.toString; //null undefined non-object function if(!obj || typeof obj !== 'object')&#123; return obj; &#125; //DOM Node if(obj.nodeType &amp;&amp; 'cloneNode' in obj)&#123; return obj.cloneNode(true); &#125; //Date if(_toString.call(obj) === '[object Date]')&#123; return new Date(obj.getTime()); &#125; //RegExp if(_toString.call(obj) === '[object RegExp]')&#123; var flags = []; if(obj.global)&#123;flags.push('g');&#125; if(obj.multiline)&#123;flags.push('m');&#125; if(obj.ignoreCase)&#123;flags.push('i');&#125; return new RegExp(obj.source,flags.join('')); &#125; var result = Array.isArray(obj) ? [] : obj.constructor ? new obj.constructor() : &#123;&#125;; for(var key in obj)&#123; result[key] = deepClone(obj[key]); &#125; return result;&#125; 完成一个函数,接受数组作为参数,数组元素为整数或者数组,数组元素包含整数或数组,函数返回扁平化后的数组,如如：[1, [2, [ [3, 4], 5], 6]] =&gt; [1, 2, 3, 4, 5, 6] 考察点：递归的编程思想 123456789101112131415var data = [1, [2, [ [3, 4], 5], 6]];var result = [];flat(data,result);console.log(result);function flat(data,result)&#123; var i,d,len; for(i = 0, len = data.length; i &lt; len; i++)&#123; d = data[i]; if(typeof d === 'number')&#123; result.push(d); &#125; else &#123; flat(d,result); &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[被问得最多的十个JavaScript前端面试问题]]></title>
      <url>%2F2016%2F11%2F28%2Finterview-04%2F</url>
      <content type="text"><![CDATA[被问得最多的十个JavaScript前端面试问题 来源：http://ourjs.com/detail/5652d266e3312b046d27f585 题目 设计一个函数返回第n行的杨辉三角 思路： 首尾都是1 中间的有a[i][j] = a[i-1][j-1] + a[i-1][j] 1234567891011121314151617function PascalTriangle(n)&#123; var a = [],i,j; for(i = 0; i &lt; n; i++)&#123; a[i] = []; a[i][0] = 1; a[i][i] = 1; &#125; for(i = 2; i &lt; n; i++)&#123; for(j = 1; j &lt; i; j++)&#123; a[i][j] = a[i-1][j-1] + a[i-1][j]; &#125; &#125; return a[n-1];&#125; 设计一个函数，返回一串字符串重复次最多的单词 思路： 分词 hash来记录对应的单词出现的次数 比较当前出现次数最大的单词，进行更新 12345678910111213141516171819function getMostFrequentWord(s)&#123; var a = s.split(/\s+/), hash = &#123;&#125;, max = a[0], i,len; for(i = 0, len = a.length; i &lt; len; i++)&#123; if(hash[a[i]])&#123; hash[a[i]]++; &#125; else &#123; hash[a[i]] = 1; &#125; if(hash[a[i]] &gt; hash[max])&#123; max = a[i]; &#125; &#125; return max;&#125; 使用递归打印长度为n的斐波那契数列 思路： f(n) = f(n-1) + f(n-2) 且 f(0) = 0,f(1) = 1 递归打印关键是要确保每个数都只打印一次，次序的问题则有递归计算的本身保证，不必担心 利用数组isPrinted来判断该f(n)是否打印过了 123456789101112131415//递归的实现方式var isPrinted = [];function f(n)&#123; var a; if(n === 0 || n === 1) &#123; a = 1; &#125; else &#123; a = f(n-1) + f(n-2) &#125; if(!isPrinted[n])&#123; console.log(a); isPrinted[n] = true; &#125; return a;&#125; 解释一下bind，apply，call的用法和区别 共同点： 都是Function原型上的属性 都可用于指定作用域，具体来说就是函数体内this的指向 用法： 1234567891011function f()&#123; console.log(this.name);&#125;var user = &#123;name : 'zhang'&#125;;//bindf.bind(user)();//apply &amp; callf.apply(user);f.call(user); 区别： apply和call区别不大，主要是参数的不同，apply可以接受数组参数。 apply和call与bind的区别就比较大了，apply和call是函数调用的方式之一，会直接执行函数，而bind只是会绑定函数体内的this的指向，但是并不会直接执行函数。 解释一下event delegation（事件代理）和它为什么有用 我们通常会在父元素上面添加事件监听和处理函数，来处理子元素的事件，而不是直接在每一个子元素上面添加事件处理函数，这种就叫做事件代理。 事件有三个阶段：捕获，处于目标，冒泡； 事件的冒泡机制正是事件代理有用的原因，在冒泡阶段，父元素可以获取得到子元素的事件，并且通过event对象获取到目标子元素，进而再进行一些操作。 事件代理是提高性能的一个重要的手段。在每一个子元素上面添加的事件处理函数都会占用浏览器的内存，消耗不少的资源，而通过事件代理，只需在父元素上面添加事件处理函数，可以提高一定的性能。 什么是event loop event loop是一种运行机制。 简单来说，就是JavaScript只有一个主线程，主线程执行完执行栈的任务后，会去循环任务队列，如果有异步事件触发，就将其添加到主线程的执行栈。 hoisting（声明提升）在JavaScript是怎么工作的 声明提升指的是在一个函数作用域内，无论在哪里声明的变量，JavaScript解析器都会将声明提升到作用域的顶部。 描述一下你在设计应用或网站时的流程 你最希望JavaScript或浏览器中添加哪些功能，为什么？ 函数式编程和命令式编程之间的区别？你喜欢哪一个？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于for的一道考题]]></title>
      <url>%2F2016%2F11%2F28%2Finterview-03%2F</url>
      <content type="text"><![CDATA[关于for的一道考题 题目12345678910var arr = [1, 2, 3]; for (var i = 0, j; j = arr[i++];) &#123; console.log(j); &#125; console.log('---------'); console.log(i); console.log('---------'); console.log(j); console.log('---------'); 输出为： 12 34undefined 结果分析 在i=3的时候，a[3]为undefined，条件判断结果为false，i++还会继续执行，此时i为4]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一道常被人轻视的前端JS面试题]]></title>
      <url>%2F2016%2F11%2F28%2Finterview-02%2F</url>
      <content type="text"><![CDATA[一道常被人轻视的前端JS面试题 来源：http://www.cnblogs.com/xxcanghai/p/5189353.html 题目1234567891011121314151617function Foo() &#123; getName = function () &#123; alert (1); &#125;; return this;&#125;Foo.getName = function () &#123; alert (2);&#125;;Foo.prototype.getName = function () &#123; alert (3);&#125;;var getName = function () &#123; alert (4);&#125;;function getName() &#123; alert (5);&#125;//请写出以下输出结果：Foo.getName();getName();Foo().getName();getName();new Foo.getName();new Foo().getName();new new Foo().getName(); 题目考察点：变量定义提升，this指针指向，运算符优先级，原型，继承，全局变量，对象属性及原型属性优先级等问题。 题目分析1234567var getName; //变量提升function Foo()&#123; getName = function () &#123; alert(1); &#125;; return this;&#125;Foo.getName = function() &#123; alert(2); &#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[7个去伪存真的JavaScript面试题]]></title>
      <url>%2F2016%2F11%2F28%2Finterview-01%2F</url>
      <content type="text"><![CDATA[7个去伪存真的JavaScript面试题 来源： http://www.codeceo.com/article/7-javascript-interview-qa.html 题目 创建JavaScript的对象的两种方法 12var o1 = &#123;&#125;;var o2 = new Object; 如何创建数组 12var a1 = [];var a2 = new Array; 什么是变量提升(Variable Hoisting) 无论在一个范围内哪个位置声明的变量，JavaScript引擎都会将这个声明移到作用域范围的顶部。 例子： 1234567var a = 0;function foo()&#123; if(false)&#123; var a = 2; &#125; console.log(a); //undefined&#125; 这段代码等于： 12345678var a = 0;function foo()&#123; var a; if(false)&#123; a = 2; &#125; console.log(a);&#125; 全局变量有什么风险，以及如何保护代码不受干扰？ 风险是：污染命名空间，也就是说其他人或者自己可能创建相同名称的变量，然后覆盖了正在使用的变量。 预防方法： 使用命名空间 12var namespace = &#123;&#125;;namespace.myVariable = 'abc'; 使用立即执行函数进行封装 123(function()&#123; var a = 'abc';&#125;)(); 如果通过JavaScript对象中的成员变量迭代 12345for (var property in obj)&#123; if(obj.hasOwnProperty(property))&#123; //do something here &#125;&#125; 什么是闭包(closure)? 有权限访问另外一个函数作用域的变量的函数。闭包可以保持值的状态，比如说一些迭代值的当前值。 1234567891011121314151617function foo()&#123; var result = [],i; for(i = 0; i &lt; 3; i++)&#123; result[i] = function()&#123; return i; &#125; &#125; return result;&#125;var result = foo();result[0](); //3result[1](); //3result[2](); //3 JavaScript的单元测试？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[异步编程-jsDeffered库解析]]></title>
      <url>%2F2016%2F11%2F28%2Fjsdeferred%2F</url>
      <content type="text"><![CDATA[1. 基础介绍JSDeferred的作者是cho45，是javascipt在异步编程上的一个里程碑式作品，值得好好学习。 2. API源码解析2.1 构造函数这里使用了安全的构造函数，避免了在没有使用new调用构造函数时出错的问题，提供了两个形式俩获取Deferred对象实例。 12345678function Deferred() &#123; return (this instanceof Deferred) ? this.init() : new Deferred();&#125;// 方式1 var o1 = new Deferred();// 方式2var o2 = Deferred(); 2.2 Deferred.define()这个方法可以包装一个对象，指定对象的方法，或者将Deferred对象的方法直接暴露在全局作用域下，这样就可以直接使用。 123456789101112131415161718Deferred.methods = ["parallel", "wait", "next", "call", "loop", "repeat", "chain"];/* @Param obj 赋予该对象Deferred的属性方法 @Param list 指定属性方法*/Deferred.define = function(obj, list)&#123; if(!list)list = Deferred.methods; // 获取全局作用域的技巧，利用立即执行函数的作用域为全局作用域的技巧 if(!obj) obj = (function getGlobal()&#123;return this&#125;)(); // 将属性都挂载到obj上 for(var i = 0; i &lt; list.length; i++)&#123; var n = list[i]; obj[n] = Deferred[n]; &#125; return Deferred;&#125;this.Deferred = Deferred; 2.3 异步的操作实现在JSDeferred中有许多异步操作的实现方式，也是作为这个框架最为出彩的地方，方法依次是： script.onreadystatechange（针对IE5.5~8） img.onerror/img.onload（针对现代浏览器的异步操作方法） 针对node环境的，使用process.nextTick来实现异步调用（已经过时） setTimeout（default） 它会视浏览器选择最快的API。 使用script的onreadystatechange事件来进行，需要注意的是由于浏览器对并发请求数有限制，（IE5.5~8为2~3，IE9+和现代浏览器为6），当并发请求数大于上限时，会让请求的发起操作排队执行，导致延时更严重。代码的思路是以150ms为一个周期，每个周期以通过setTimeout发起的异步执行为起始，周期内的其他异步执行操作通过script请求实现，如果此方法被频繁调用的话，说明达到并发请求数上限的可能性越高，因此可以下调一下周期时间，例如设为100ms，避免因排队导致的高延时。 12345678910111213141516171819202122232425262728293031323334353637383940Deferred.next_faster_way_readystatechange = ((typeof window === "object") &amp;&amp; (location.protocol == "http:") &amp;&amp; !window.opera &amp;&amp; /\bMSIE\b/.test(navigator.userAgent)) &amp;&amp; function (fun) &#123; var d = new Deferred(); var t = new Date().getTime(); if(t - arguments.callee._prev_timeout_called &lt; 150)&#123; var cancel = false; // 因为readyState会一直变化，避免重复执行 var script = document.createElement("script"); script.type = "text/javascript"; // 发送一个错误的url，快速触发回调，实现异步操作 script.src = "data:text/javascript,"; script.onreadystatechange = function () &#123; if(!cancel)&#123; d.canceller(); d.call(); &#125; &#125;; d.canceller = function () &#123; if(!cancel)&#123; cancel = true; script.onreadystatechange = null; document.body.removeChild(script);// 移除节点 &#125; &#125;； // 不同于img，需要添加到文档中才会发送请求 document.body.appendChild(script); &#125; else &#123; // 记录或重置起始时间 arguments.callee._prev_timeout_called = t; // 每个周期开始使用setTimeout var id = setTimeout(function ()&#123; d.call()&#125;, 0); d.canceller = function () &#123;clearTimeout(id)&#125;; &#125; if(fun)d.callback.ok = fun; return d;&#125; 使用img的方式，利用src属性报错和绑定事件回调的方式来进行异步操作 12345678910111213141516171819202122Deferred.next_faster_way_Image = ((typeof window === "object") &amp;&amp; (typeof Image != "undefined") &amp;&amp; !window.opera &amp;&amp; document.addEventListener) &amp;&amp; function (fun)&#123; var d = new Deffered(); var img = new Image(); var hander = function () &#123; d.canceller(); d.call(); &#125; img.addEventListener("load", handler, false); img.addEventListener("error", handler, false); d.canceller = function ()&#123; img.removeEventListener("load", handler, false); img.removeEventListener("error", handler, false); &#125; // 赋值一个错误的URL img.src = "data:imag/png," + Math.random(); if(fun) d.callback.ok = fun; return d;&#125; 针对Node环境的，使用process.nextTick来实现异步调用 12345678Deferred.next_tick = (typeof process === 'object' &amp;&amp; typeof process.nextTick === 'function') &amp;&amp; function (fun) &#123; var d = new Deferred(); process.nextTick(function() &#123; d.call() &#125;); if (fun) d.callback.ok = fun; return d;&#125;; setTimeout的方式，这种方式有一个触发最小的时间间隔，在旧的IE浏览器中，时间间隔可能会稍微长一点（15ms）。 12345678910111213141516Deferred.next_default = function (fun) &#123; var d = new Deferred(); var id = setTimeout(function()&#123; clearTimeout(id); d.call(); // 唤起Deferred调用链 &#125;, 0) d.canceller = function () &#123; try&#123; clearTimeout(id); &#125;catch(e)&#123;&#125; &#125;; if(fun)&#123; d.callback.ok = fun; &#125; return d;&#125; 默认的顺序为 12345Deferred.next = Deferred.next_faster_way_readystatechange || // 处理IE Deferred.next_faster_way_Image || // 现代浏览器 Deferred.next_tick || // node环境 Deferred.next_default; // 默认行为 根据JSDeferred官方的数据，使用next_faster_way_readystatechange和next_faster_way_Image这两个比原有的setTimeout异步的方式快上700%以上。 看了一下数据，其实对比的浏览器版本都相对比较旧，在现代的浏览器中性能提升应该就没有那么明显了。 2.4 原型方法Deferred的原型方法中实现了 _id 用来判断是否是Deferred的实例，原因好像是Mozilla有个插件也叫Deferred，因此不能通过instanceof来检测。cho45于是自定义标志位来作检测，并在github上提交fxxking Mozilla。 init 初始化，给每个实例附加一个_next和callback属性 next 用于注册调用函数，内部以链表的方式实现，节点为Deferred实例，调用的内部方法_post error 用于注册函数调用失败时的错误信息，与next的内部实现一致。 call 唤起next调用链 fail 唤起error调用链 cancel 执行cancel回调，只有在唤起调用链之前调用才有效。（调用链是单向的，执行之后就不可返回） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950Deferred.prototype = &#123; _id : 0xe38286e381ae, // 用于判断是否是实例的标识位 init : function () &#123; this._next = null; // 一种链表的实现思路 this.callback = &#123; ok : Deferred.ok, // 默认的ok回调 ng : Deferred.ng // 出错时的回调 &#125;; return this; &#125;, next : function (fun) &#123; return this._post("ok", fun); // 调用_post建立链表 &#125;, error : function (fun) &#123; return this._post("ng", fun); // 调用_post建立链表 &#125;, call : function(val) &#123; return this._fire("ok", val); // 唤起next调用链 &#125;, fail : function (err) &#123; return this._fire("ng", err); // 唤起error调用链 &#125;, cancel : function () &#123; (this.canceller || function () &#123;&#125;).apply(this); return this.init(); // 进行重置 &#125;, _post : function (okng, fun)&#123; // 建立链表 this._next = new Deferred(); this._next.callback[okng] = fun; return this._next; &#125;, _fire : function (okng, fun)&#123; var next = "ok"; try&#123; // 注册的回调函数中，可能会抛出异常，用try-catch进行捕捉 value = this.callback[okng].call(this, value); &#125; catch(e) &#123; next = "ng"; value = e; // 传递出错信息 if (Deferred.onerror) Deferred.onerror(e); // 发生错误的回调 &#125; if (Deferred.isDeferred(value)) &#123; // 判断是否是Deferred的实例 // 这里的代码就是给Deferred.wait方法使用的， value._next = this._next; &#125; else &#123; // 如果不是，则继续执行 if (this._next) this._next._fire(next, value); &#125; return this; &#125;&#125; 2.5 辅助静态方法上面的代码中，可以看到一些Deferred对象的方法（静态方法），下面简单介绍一下： 12345678910// 默认的成功回调Deferred.ok = function (x) &#123;return x&#125;;// 默认的失败回调Deferred.ng = function (x) &#123;throw x&#125;;// 根据_id判断实例的实现Deferred.isDeferred = function (obj) &#123; return !!(obj &amp;&amp; obj._id === Deferred.prototype._id);&#125; 2.6 简单小结看到这里，我们需要停下来，看看一个简单的例子，来理解整个流程。 Defferred对象自身有next属性方法，在原型上也定义了next方法，需要注意这一点，例如以下代码： 1234567var o = &#123;&#125;;Deferred.define(o);o.next(function fn1()&#123; console.log(1);&#125;).next(function fn2()&#123; console.log(2);&#125;); o.next()是Deffered对象的属性方法，这个方法会返回一个Defferred对象的实例，因此下一个next()则是原型上的next方法。 第一个next()方法将后续的代码变成异步操作，后面的next()方法实际上是注册调用函数。 在第一个next()的异步操作里面唤起后面next()的调用链（d.call()），开始顺序的调用，换句话说就是，fn1和fn2是同步执行的。 那么，如果我们希望fn1和fn2也是异步执行，而不是同步执行的，这就得借助Deferred.wait方法了。 2.7 wait &amp; register我们可以使用wait来让fn1和fn2变成异步执行，代码如下： 12345Deferred.next(function fn1() &#123; console.log(1)&#125;).wait(0).next(function fn2() &#123; console.log(2)&#125;); wait方法很有意思，在Deferred的原型上并没有wait方法，而是在静态方法上找到了。 12345678910111213Deferred.wait = function (n) &#123; var d = new Deferred(), t = new Date(); // 使用定时器来变成异步操作 var id = setTimeout(function () &#123; d.call((new Date()).getTime() - t.getTime()); &#125;, n * 1000); d.canceller = function () &#123; clearTimeout(id); &#125; return d;&#125; 那么这个方法是怎么放到原型上的？原来是通过Deferred.register进行函数转换，绑定到原型上的。 1234567891011Deferred.register = function (name, fun)&#123; this.prototype[name] = function () &#123; // 柯里化 var a = arguments; return this.next(function()&#123; return fun.apply(this, a); &#125;); &#125;&#125;;// 将方法注册到原型上Deferred.register("wait", Deferred.wait); 我们需要思考为什么要用这种方式将wait方法register到Deferred的原型对象上去？，因为明显这种方式有点难以理解。 结合例子，我们进行讨论，便能够彻底地理解上述的问题。 1234567Deferred.next(function fn1()&#123; // d1 console.log(1);&#125;).wait(1) // d2.next(function fn2()&#123; // d3 console.log(2);&#125;); 这段代码首先会建立一个调用链 之后，执行的过程为（如图所示） 我们来看看执行过程的几个关键点 图中的d1、d2、d3、d_wait表示在调用链上生成的Deferred对象的实例 在调用了d2的callback.ok即包装了wait()方法的匿名函数之后，返回了在wait()方法中生成的Deferred对象的实例d_wait，保存在变量value中，在_fire()方法中有一个if判断 123if(Deferred.isDeferred(value))&#123; value._next = this._next;&#125; 在这里并没有继续往下执行调用链的函数，而是重新建立了一个调用链，此时链头为d_wait，在wait()方法中使用setTimeout，使其异步执行，使用d.call()重新唤起调用链。 理解了整个过程，就比较好回到上面的问题了。之所以使用register的方式是因为原型上的wait方法并非直接使用Deferred.wait，而是把Deferred.wait方法作为参数，对原型上的next()方法进行curry化，然后返回一个柯里化之后的next()方法。而Deferred.wait()其实和Deferred.next()的作用很类似，都是异步执行接下来的操作。 2.8 并归结果 parallel设想一个场景，我们需要多个异步网络查询任务，这些任务没有依赖关系，不需要区分前后，但是需要等待所有查询结果回来之后才能进一步处理，那么你会怎么做？在比较复杂的应用中，这个场景经常会出现，如果我们采用以下的方式（见伪代码） 12345678var result = [];$.ajax("task1", function(ret1)&#123; result.push(ret1); $.ajax("task2", function(ret2)&#123; result.push(ret2); // 进行操作 &#125;);&#125;); 这种方式可以，但是却无法同时发送task1和task2（从代码上看还以为之间有依赖关系，实际上没有）。那怎么解决？这就是Deferred.parallel()所要解决的问题。 我们先来个简单的例子感受一下这种并归结果的方式。 123456789Deferred.parallel(function () &#123; return 1;&#125;, function () &#123; return 2;&#125;, function () &#123; return 3;&#125;).next(function (a) &#123; console.log(a); // [1,2,3]&#125;); 在parallel()方法执行之后，会将结果合并为一个数组，然后传递给next()中的callback.ok中。可以看到parallel里面都是同步的方法，先来看看parallel的源码是如何实现，再来看看能不能结合所学来改造实现我们所需要的ajax的效果。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273Deferred.parallel = function (dl) &#123; /* 前面都是对参数的处理，可以接收三种形式的参数 1. parallel(fn1, fn2, fn3).next() 2. parallel(&#123; foo : $.get("foo.html"), bar : $.get("bar.html") &#125;).next(function (v)&#123; v.foo // =&gt; foo.html data v.bar // =&gt; bar.html data &#125;); 3. parallel([fn1, fn2, fn3]).next(function (v) &#123; v[0] // fn1执行的结果 v[1] // fn2执行的结果 v[3] // fn3执行返回的结果 &#125;); */ var isArray = false; // 第一种形式 if (arguments.length &gt; 1) &#123; dl = Array.prototype.slice.call(arguments); isArray = true; // 其余两种形式，数组，类数组 &#125; else if (Array.isArray &amp;&amp; Array.isArray(dl) || typeof dl.length == "number") &#123; isArray = true; &#125; var ret = new Deferred(), // 用于归并结果的Deferred对象的实例 value = &#123;&#125;, // 收集函数执行的结果 num = 0 ; // 计数器，当为0时说明所有任务都执行完毕 // 开始遍历，这里使用for-in其实效率不高 for (var i in dl) &#123; // 预防遍历了所有属性，例如toString之类的 if (dl.hasOwnProperty(i)) &#123; // 利用闭包保存变量状态 (function (d, i)&#123; // 使用Deferred.next()开始一个异步任务，并且执行完成之后，收集结果 if (typeof d == "function") dl[i] = d = Deferred.next(d); d.next(function (v) &#123; values[i] = v; if( --num &lt;= 0)&#123; // 计数器为0说明所有任务已经完成，可以返回 if(isArray)&#123; // 如果是数组的话，结果可以转换成数组 values.length = dl.length; values = Array.prototype.slice.call(values, 0); &#125; // 调用parallel().next(function(v)&#123;&#125;)，唤起调用链 ret.call(values); &#125; &#125;).error(function (e) &#123; ret.fail(e); &#125;); num++; // 计数器加1 &#125;)(d[i], i); &#125; &#125; // 当计算器为0的时候，处理可能没有参数或者非法参数的情况 if (!num) &#123; Deferred.next(function () &#123; ret.call(); &#125;); &#125; ret.canceller = function () &#123; for (var i in dl) &#123; if (dl.hasOwnProperty(i)) &#123; dl[i].cancel(); &#125; &#125; &#125;; return ret; // 返回Deferred实例&#125;; 结合上述知识，我们可以在parallel中使用异步方法，代码如下 12345678910111213141516Deferred.parallel(function fn1()&#123; var d = new Deferred(); $.ajax("task1", function(ret1)&#123; d.call(ret1); &#125;); return d;&#125;, function () &#123; var d = new Deferred(); $.ajax("task2", function fn2(ret2) &#123; d.call(ret2) &#125;); return d;&#125;).next(function fn3(ret) &#123; ret[0]; // =&gt; task1返回的结果 ret[1]; // =&gt; task2返回的结果&#125;); 为什么可以这样？我们来图解一下，加深一下理解。 我们使用了_fire中的if判断，建立了新的调用链，获得去统计计数函数（即parallel中–num）的控制权，从而使得在parallel执行异步的方法。 TBD). 参考资料 jsdeferred.js jsDeferred API JavaScript框架设计]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一步步打造thunkify]]></title>
      <url>%2F2016%2F11%2F28%2Fthunk%2F</url>
      <content type="text"><![CDATA[通过学习thunk的含义，我们来实现一个简单的thunkify函数库，并且通过测试代码，来改善我们的代码，是我们能够对这个函数库有更加深刻的理解。 1. 诞生背景Thunk函数的诞生是源于一个编译器设计的问题：求值策略，即函数的参数到底应该何时求值。 例如： 12345var x = 1;function f(m) &#123; return m * 2;&#125;f(x + 5); 其中x+5这个表达式应该什么时候求值，有两种思路 传值调用(call by value)，即在进入函数体之间，先计算x+5的值，再将这个值（6）传入函数f，例如c语言，这种做法的好处是实现比较简单，但是有可能会造成性能损失。 传名调用(call by name)，即直接将表达式(x+5)传入函数体，只在用到它的时候求值。 2. Thunk函数的含义编译器的传名调用实现，往往就是将参数放到一个临时函数之中，再将这个临时函数转入函数体，这个临时函数就叫做Thunk函数。 来看一段代码示例： 1234567891011121314function f(m) &#123; return m*2;&#125;f(x + 5);// 等价于以下代码var thunk = function () &#123; return x + 5;&#125;;function f(thunk) &#123; return thunk() * 2;&#125; 3. javascript中的Thunk函数我们都知道Javascript是传值调用的，那么js中的Thunk函数又是怎么回事？ 在Javascript语言中，Thunk函数替换的不是表达式，而是多参数函数，将其替换成单参数的版本，且只接受回调函数作为参数。 还是通过代码来理解，即 123456// 正常版本的readFile，需要两个参数filename、callbackfs.readFile(fileName, callback);// thunk版本的readFilevar readFileThunk = thunkify(fs.readFile);readFileThunk(fileName)(callback); 原文中例子就是柯里化，预置参数fileName，直接调用fs.readFile 好，现在我们来思考如何实现thunkify函数。我们从调用的形式来看，返回的应该是一个高阶函数，即返回一个函数a，a的返回还是一个函数。 1234567var thunkify = function (fn) &#123; return function () &#123; return function () &#123; &#125; &#125;&#125;; 结合上述例子，因为是包装函数，因此最终还是readFile执行，且需要fileName，因此： 123456789var thunkify = function (fn) &#123; return function () &#123; var args = Array.prototype.slice.call(arguments); return function (callback) &#123; args.push(callback); return fn.apply(this, args); &#125; &#125;&#125;; 这样似乎很完美，我们运行整个示例 12345678910111213141516const fs = require('fs');var thunkify = function (fn) &#123; return function () &#123; var args = Array.prototype.slice.call(arguments); return function (callback) &#123; args.push(callback); return fn.apply(this, args); &#125; &#125;&#125;;var readFileThunk = thunkify(fs.readFile);readFileThunk('test.txt', 'utf-8')( (err, data) =&gt; &#123; console.log(data);&#125;); 运行结果为 4. 打造thunkify模块要写出一个健壮的thunkify函数，需要考虑的各种情况，而我们通过tj大神写的thunkify模块的测试代码，来看看我们自己的thunkify还存在哪些不足，一步步来优化。 1、保存上下文的问题 123456789101112function load(fn) &#123; fn(null, this.name);&#125;var user = &#123; name: 'tobi', load: thunkify(load)&#125;;user.load()((err, res) =&gt; &#123; console.log(res);&#125;); 运行之后，res的结果为undefined，原因是没有保存上下文，改进一下 12345678910var thunkify = function (fn) &#123; return function () &#123; var args = Array.prototype.slice.call(arguments); var ctx = this; return function (callback) &#123; args.push(callback); return fn.apply(ctx, args); &#125; &#125;&#125;; 2、捕抓错误 12345function load(fn) &#123; throw new Error('boom');&#125;load = thunkify(load);load()(err =&gt; console.log(err.message)); 运行之后，发现并没有捕抓到错误，我们需要执行函数进行try/catch，并且当出错时，传递出错信息。 1234567891011121314151617var thunkify = function (fn) &#123; return function () &#123; var args = Array.prototype.slice.call(arguments); var ctx = this; return function (callback) &#123; args.push(callback); var result; // try/catch捕抓信息，并且出错时，传递给回调函数 try &#123; result = fn.apply(ctx, args); &#125; catch (e) &#123; callback(e); &#125; return result; &#125; &#125;&#125;; 3、回调函数应该只调用一次。 123456789function load(fn) &#123; fn(null, 1); fn(null, 2); fn(null, 3);&#125;load = thunkify(load);load()((err,ret) =&gt; console.log(ret)); 运行输出结果为1 2 3，而我们期望结果只为1，那么需要判断callback是否已经执行过了，使其只执行一次。 12345678910111213141516171819202122var thunkify = function (fn) &#123; return function () &#123; var args = Array.prototype.slice.call(arguments); var ctx = this; return function (callback) &#123; var called; // 对callback进行封装，使其只能执行一次。 args.push(function () &#123; if(called) return; called = true; callback.apply(null, arguments); &#125;); var result; try &#123; result = fn.apply(ctx, args); &#125; catch (e) &#123; callback(e); &#125; return result; &#125; &#125;&#125;; 到这里，我们通过了所有的测试，完成了一个健壮的thunkify模块。 5. 来源 Thunk-阮一峰 thunkify-tj]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2F11%2F28%2FHello-World%2F</url>
      <content type="text"><![CDATA[这是新环境下的第一篇博客，总结一下之前写过的东西，以后会不断在这上面增加自己的文章。 1. 之前的文章1. sourcecode 最开始写的一些文章，主要都是前端的内容，还有整理的一些前端面试的资料，计算机基础等等。 2. node-learning 在学习node过程中的一些笔记和代码，目前大部分内容是关于koa框架的，加深自己对web框架的理解。 3. linux-usages linux下一些常见的软件、使用操作的笔记 4. front-end 开始于对sourcecode项目的整理，之后又新增了很多的内容，例如移动web的开发、工具、浏览器内核等。由于gitbook.com是外国服务器，在国内的访问不太稳定。决心还是放弃。]]></content>
    </entry>

    
  
  
</search>
